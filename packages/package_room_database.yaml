# Room Database Package - SQL-driven room configuration management
# Consolidates SQL sensors, REST commands, shell commands, and recorder policies
# Used by AppDaemon room_db_updater app for centralized room configuration

# SQL sensors for reading room configurations from SQLite database
sql:
  - name: "Room Configs — Motion Lighting"
    db_url: sqlite:////config/room_database.db
    query: >
      SELECT 'ok' AS state,
             json_group_object(
               room_id,
               CASE WHEN json_valid(config_data)
                    THEN json(config_data)
                    ELSE NULL
               END
             ) AS payload
      FROM room_configs
      WHERE config_domain = 'motion_lighting';
    column: state

  - name: "Room Configs — Vacuum Control"
    db_url: sqlite:////config/room_database.db
    query: >
      SELECT 'ok' AS state,
             json_group_object(
               room_id,
               CASE WHEN json_valid(config_data)
                    THEN json(config_data)
                    ELSE NULL
               END
             ) AS payload
      FROM room_configs
      WHERE config_domain = 'vacuum_control';
    column: state

  - name: "Rooms Needing Cleaning"
    db_url: sqlite:////config/room_database.db
    query: >
      SELECT
        json_array_length(COALESCE(json_group_array(room_id),'[]')) AS count,
        COALESCE(json_group_array(room_id),'[]') AS payload
      FROM room_configs
      WHERE config_domain = 'vacuum_control'
        AND json_extract(config_data, '$.needs_cleaning') = 1;
    column: count

# REST commands for AppDaemon HTTP API interaction
rest_command:
  room_db_update_config:
    url: "http://a0d7b954-appdaemon:5050/api/appdaemon/room_db/update_config"
    method: POST
    content_type: "application/json"
    payload: >-
      {"room_id": "{{ room_id }}", "domain": "{{ domain }}", "config_data": {{ config_data }} }

  room_db_health:
    url: "http://a0d7b954-appdaemon:5050/api/appdaemon/room_db/health"
    method: GET
    timeout: 10
    headers:
      accept: application/json

# Shell commands for direct SQLite database operations (fallback/emergency use)
shell_command:
  update_room_config: |
    /bin/sh -c 'command -v sqlite3 >/dev/null 2>&1 || exit 123;
    test -f /config/domain/architecture/area_mapping.yaml || exit 125;
    grep -Eq "(^|[[:space:]]){{ room_id }}:" /config/domain/architecture/area_mapping.yaml || exit 126;
    sqlite3 /config/room_database.db "PRAGMA journal_mode=WAL; PRAGMA synchronous=NORMAL; CREATE TABLE IF NOT EXISTS write_guard(domain TEXT PRIMARY KEY, last_ts INTEGER); CREATE TABLE IF NOT EXISTS schema_version(version INTEGER); CREATE TABLE IF NOT EXISTS room_configs(room_id TEXT, config_domain TEXT, config_data TEXT, updated_at TEXT, PRIMARY KEY(room_id, config_domain)); BEGIN IMMEDIATE; SELECT CASE WHEN (SELECT version FROM schema_version)={{ schema_expected }} THEN 1 ELSE RAISE(ABORT,\"SCHEMA_VERSION_MISMATCH\") END; SELECT CASE WHEN \"{{ domain }}\" IN (\"motion_lighting\",\"vacuum_control\",\"shared\") THEN 1 ELSE RAISE(ABORT,\"DOMAIN_NOT_ALLOWED\") END; SELECT CASE WHEN \"{{ room_id }}\" GLOB \"[a-z0-9_]*\" AND LENGTH(\"{{ room_id }}\")>0 THEN 1 ELSE RAISE(ABORT,\"BAD_ROOM_ID\") END; SELECT CASE WHEN LENGTH(\"{{ config_data }}\") <= 4096 THEN 1 ELSE RAISE(ABORT,\"CONFIG_TOO_LARGE\") END; SELECT CASE WHEN COALESCE(strftime(\"%s\",\"now\") - (SELECT last_ts FROM write_guard WHERE domain=\"{{ domain }}\"), 9999) >= 2 THEN 1 ELSE RAISE(ABORT,\"WRITE_RATE_LIMIT\") END; INSERT OR REPLACE INTO room_configs (room_id, config_domain, config_data, updated_at) VALUES (\"{{ room_id }}\",\"{{ domain }}\",\"{{ config_data }}\", datetime(\"now\")); INSERT OR REPLACE INTO write_guard(domain,last_ts) VALUES(\"{{ domain }}\", strftime(\"%s\",\"now\")); COMMIT;"'

  update_motion_timeout: |
    /bin/sh -c 'command -v sqlite3 >/dev/null 2>&1 || exit 123;
    test -f /config/domain/architecture/area_mapping.yaml || exit 125;
    grep -Eq "(^|[[:space:]]){{ room_id }}:" /config/domain/architecture/area_mapping.yaml || exit 126;
    sqlite3 /config/room_database.db "PRAGMA journal_mode=WAL; PRAGMA synchronous=NORMAL; CREATE TABLE IF NOT EXISTS write_guard(domain TEXT PRIMARY KEY, last_ts INTEGER); CREATE TABLE IF NOT EXISTS schema_version(version INTEGER); CREATE TABLE IF NOT EXISTS room_configs(room_id TEXT, config_domain TEXT, config_data TEXT, updated_at TEXT, PRIMARY KEY(room_id, config_domain)); BEGIN IMMEDIATE; SELECT CASE WHEN (SELECT version FROM schema_version)={{ schema_expected }} THEN 1 ELSE RAISE(ABUSE,\"SCHEMA_VERSION_MISMATCH\") END; SELECT CASE WHEN \"{{ room_id }}\" GLOB \"[a-z0-9_]*\" AND LENGTH(\"{{ room_id }}\")>0 THEN 1 ELSE RAISE(ABORT,\"BAD_ROOM_ID\") END; SELECT CASE WHEN COALESCE(strftime(\"%s\",\"now\") - (SELECT last_ts FROM write_guard WHERE domain=\"motion_lighting\"), 9999) >= 2 THEN 1 ELSE RAISE(ABORT,\"WRITE_RATE_LIMIT\") END; UPDATE room_configs SET config_data = json_set(config_data, \"$.timeout\", {{ timeout }}), updated_at = datetime(\"now\") WHERE room_id=\"{{ room_id }}\" AND config_domain=\"motion_lighting\"; INSERT OR REPLACE INTO write_guard(domain,last_ts) VALUES(\"motion_lighting\", strftime(\"%s\",\"now\")); COMMIT;"'

  mark_room_cleaned: |
    /bin/sh -c 'command -v sqlite3 >/dev/null 2>&1 || exit 123;
    test -f /config/domain/architecture/area_mapping.yaml || exit 125;
    grep -Eq "(^|[[:space:]]){{ room_id }}:" /config/domain/architecture/area_mapping.yaml || exit 126;
    sqlite3 /config/room_database.db "PRAGMA journal_mode=WAL; PRAGMA synchronous=NORMAL; CREATE TABLE IF NOT EXISTS write_guard(domain TEXT PRIMARY KEY, last_ts INTEGER); CREATE TABLE IF NOT EXISTS schema_version(version INTEGER); CREATE TABLE IF NOT EXISTS room_configs(room_id TEXT, config_domain TEXT, config_data TEXT, updated_at TEXT, PRIMARY KEY(room_id, config_domain)); BEGIN IMMEDIATE; SELECT CASE WHEN (SELECT version FROM schema_version)={{ schema_expected }} THEN 1 ELSE RAISE(ABORT,\"SCHEMA_VERSION_MISMATCH\") END; SELECT CASE WHEN COALESCE(strftime(\"%s\",\"now\") - (SELECT last_ts FROM write_guard WHERE domain=\"vacuum_control\"), 9999) >= 2 THEN 1 ELSE RAISE(ABORT,\"WRITE_RATE_LIMIT\") END; UPDATE room_configs SET config_data = json_set(config_data, \"$.last_cleaned\", datetime(\"now\"), \"$.needs_cleaning\", 0), updated_at = datetime(\"now\") WHERE room_id=\"{{ room_id }}\" AND config_domain=\"vacuum_control\"; INSERT OR REPLACE INTO write_guard(domain,last_ts) VALUES(\"vacuum_control\", strftime(\"%s\",\"now\")); COMMIT;"'

# Recorder policy to exclude SQL sensors from history (prevent database bloat)
recorder:
  exclude:
    entity_globs:
      - sensor.room_configs_*
      - sensor.rooms_needing_cleaning