# Room Database Package - SQL-driven room configuration management
# Consolidates SQL sensors, REST commands, shell commands, and recorder policies
# Used by AppDaemon room_db_updater app for centralized room configuration

# REST commands for AppDaemon HTTP API interaction
# Per AppDaemon docs and live verification, the add-on exposes endpoints globally:
#   Primary: /api/appdaemon/<endpoint>
# RoomDbUpdater registers: health, test, update_config (global, unique names)
# App-scoped and compat nested variants remain as alternates for reference.
rest_command:
  room_db_update_config:
    url: "http://a0d7b954-appdaemon:5050/api/appdaemon/room_db_update_config"
    method: POST
    content_type: "application/json"
    timeout: 20
    payload: >
      {
        "room_id": "{{ room_id }}",
        "domain": "{{ domain }}",
        "config_data": {{ config_data | tojson }},
        "schema_expected": {{ schema_expected|default(1) }}
      }

  room_db_health:
    url: "http://a0d7b954-appdaemon:5050/api/appdaemon/room_db_health"
    method: GET
    timeout: 10

  room_db_test:
    url: "http://a0d7b954-appdaemon:5050/api/appdaemon/room_db_test"
    method: GET
    timeout: 10
    headers:
      accept: application/json

  # Alternate commands (app-scoped): useful for environments that expose per-app paths
  room_db_update_config_app:
    url: "http://a0d7b954-appdaemon:5050/api/app/room_db_updater/update_config"
    method: POST
    content_type: "application/json"
    timeout: 20
    payload: >
      {
        "room_id": "{{ room_id }}",
        "domain": "{{ domain }}",
        "config_data": {{ config_data | tojson }},
        "schema_expected": {{ schema_expected|default(1) }}
      }

  room_db_health_app:
    url: "http://a0d7b954-appdaemon:5050/api/app/room_db_updater/health"
    method: GET
    timeout: 10

  # Compat nested alternates (registered in this app for backward-compat)
  room_db_update_config_compat:
    url: "http://a0d7b954-appdaemon:5050/api/app/room_db_updater/room_db/update_config"
    method: POST
    content_type: "application/json"
    timeout: 20
    payload: >
      {
        "room_id": "{{ room_id }}",
        "domain": "{{ domain }}",
        "config_data": {{ config_data | tojson }},
        "schema_expected": {{ schema_expected|default(1) }}
      }

  room_db_health_compat:
    url: "http://a0d7b954-appdaemon:5050/api/app/room_db_updater/room_db/health"
    method: GET
    timeout: 10

sql:
  - name: "Room Configs — Motion Lighting"
    db_url: sqlite:////config/room_database.db
    query: >
      SELECT 'ok' AS state,
             json_group_object(
               room_id,
               CASE WHEN json_valid(config_data) = 1
                    THEN json(config_data)
                    ELSE NULL
               END
             ) AS payload
      FROM room_configs
      WHERE config_domain = 'motion_lighting';
    column: state

  - name: "Room Configs — Vacuum Control"
    db_url: sqlite:////config/room_database.db
    query: >
      SELECT 'ok' AS state,
             json_group_object(
               room_id,
               CASE WHEN json_valid(config_data) = 1
                    THEN json(config_data)
                    ELSE NULL
               END
             ) AS payload
      FROM room_configs
      WHERE config_domain = 'vacuum_control';
    column: state

  - name: "Rooms Needing Cleaning"
    db_url: sqlite:////config/room_database.db
    query: >
      SELECT
        json_array_length(COALESCE(json_group_array(room_id),'[]')) AS count,
        COALESCE(json_group_array(room_id),'[]') AS payload
      FROM room_configs
      WHERE config_domain = 'vacuum_control'
        AND json_extract(config_data, '$.needs_cleaning') = 1;
    column: count

# Shell commands for direct SQLite database operations (fallback/emergency use)
shell_command:
  update_room_config: |
    /bin/sh -c '
    SQLITE_CMD="$(command -v sqlite3 2>/dev/null || echo /usr/bin/sqlite3)";
    if [ ! -x "$SQLITE_CMD" ]; then echo "sqlite3 not found" >&2; exit 123; fi;
    if [ ! -f /config/www/area_mapping.yaml ]; then echo "area_mapping.yaml missing" >&2; exit 125; fi;
    if ! grep -Eq "(^|[[:space:]]){{ room_id }}:" /config/www/area_mapping.yaml 2>/dev/null; then echo "room_id validation failed" >&2; exit 126; fi;
    "$SQLITE_CMD" /config/room_database.db "PRAGMA journal_mode=WAL; PRAGMA synchronous=NORMAL; CREATE TABLE IF NOT EXISTS write_guard(domain TEXT PRIMARY KEY, last_ts INTEGER); CREATE TABLE IF NOT EXISTS schema_version(version INTEGER); CREATE TABLE IF NOT EXISTS room_configs(room_id TEXT, config_domain TEXT, config_data TEXT, updated_at TEXT, PRIMARY KEY(room_id, config_domain)); BEGIN IMMEDIATE; SELECT CASE WHEN (SELECT version FROM schema_version)={{ schema_expected }} THEN 1 ELSE RAISE(ABORT,\"SCHEMA_VERSION_MISMATCH\") END; SELECT CASE WHEN \"{{ domain }}\" IN (\"motion_lighting\",\"vacuum_control\",\"shared\") THEN 1 ELSE RAISE(ABORT,\"DOMAIN_NOT_ALLOWED\") END; SELECT CASE WHEN \"{{ room_id }}\" GLOB \"[a-z0-9_]*\" AND LENGTH(\"{{ room_id }}\")>0 THEN 1 ELSE RAISE(ABORT,\"BAD_ROOM_ID\") END; SELECT CASE WHEN LENGTH(\"{{ config_data }}\") <= 4096 THEN 1 ELSE RAISE(ABORT,\"CONFIG_TOO_LARGE\") END; SELECT CASE WHEN COALESCE(strftime(\"%s\",\"now\") - (SELECT last_ts FROM write_guard WHERE domain=\"{{ domain }}\"), 9999) >= 2 THEN 1 ELSE RAISE(ABORT,\"WRITE_RATE_LIMIT\") END; INSERT OR REPLACE INTO room_configs (room_id, config_domain, config_data, updated_at) VALUES (\"{{ room_id }}\",\"{{ domain }}\",\"{{ config_data }}\", datetime(\"now\")); INSERT OR REPLACE INTO write_guard(domain,last_ts) VALUES(\"{{ domain }}\", strftime(\"%s\",\"now\")); COMMIT;" 2>/dev/null || echo "SQLite operation failed" >&2
    '

  update_motion_timeout: |
    /bin/sh -c '
    SQLITE_CMD="$(command -v sqlite3 2>/dev/null || echo /usr/bin/sqlite3)";
    if [ ! -x "$SQLITE_CMD" ]; then echo "sqlite3 not found" >&2; exit 125; fi;
    if [ ! -f /config/www/area_mapping.yaml ]; then echo "area_mapping.yaml missing" >&2; exit 125; fi;
    if ! grep -Eq "(^|[[:space:]]){{ room_id }}:" /config/www/area_mapping.yaml 2>/dev/null; then echo "room_id validation failed" >&2; exit 126; fi;
    "$SQLITE_CMD" /config/room_database.db "PRAGMA journal_mode=WAL; PRAGMA synchronous=NORMAL; CREATE TABLE IF NOT EXISTS write_guard(domain TEXT PRIMARY KEY, last_ts INTEGER); CREATE TABLE IF NOT EXISTS schema_version(version INTEGER); CREATE TABLE IF NOT EXISTS room_configs(room_id TEXT, config_domain TEXT, config_data TEXT, updated_at TEXT, PRIMARY KEY(room_id, config_domain)); BEGIN IMMEDIATE; SELECT CASE WHEN (SELECT version FROM schema_version)={{ schema_expected }} THEN 1 ELSE RAISE(ABORT,\"SCHEMA_VERSION_MISMATCH\") END; SELECT CASE WHEN \"{{ room_id }}\" GLOB \"[a-z0-9_]*\" AND LENGTH(\"{{ room_id }}\")>0 THEN 1 ELSE RAISE(ABORT,\"BAD_ROOM_ID\") END; SELECT CASE WHEN COALESCE(strftime(\"%s\",\"now\") - (SELECT last_ts FROM write_guard WHERE domain=\"motion_lighting\"), 9999) >= 2 THEN 1 ELSE RAISE(ABORT,\"WRITE_RATE_LIMIT\") END; UPDATE room_configs SET config_data = json_set(config_data, \"$.timeout\", {{ timeout }}), updated_at = datetime(\"now\") WHERE room_id=\"{{ room_id }}\" AND config_domain=\"motion_lighting\"; INSERT OR REPLACE INTO write_guard(domain,last_ts) VALUES(\"motion_lighting\", strftime(\"%s\",\"now\")); COMMIT;" 2>/dev/null || echo "SQLite operation failed" >&2
    '

  mark_room_cleaned: |
    /bin/sh -c '
    SQLITE_CMD="$(command -v sqlite3 2>/dev/null || echo /usr/bin/sqlite3)";
    if [ ! -x "$SQLITE_CMD" ]; then echo "sqlite3 not found" >&2; exit 123; fi;
    if [ ! -f /config/www/area_mapping.yaml ]; then echo "area_mapping.yaml missing" >&2; exit 125; fi;
    if ! grep -Eq "(^|[[:space:]]){{ room_id }}:" /config/www/area_mapping.yaml 2>/dev/null; then echo "room_id validation failed" >&2; exit 126; fi;
    "$SQLITE_CMD" /config/room_database.db "PRAGMA journal_mode=WAL; PRAGMA synchronous=NORMAL; CREATE TABLE IF NOT EXISTS write_guard(domain TEXT PRIMARY KEY, last_ts INTEGER); CREATE TABLE IF NOT EXISTS schema_version(version INTEGER); CREATE TABLE IF NOT EXISTS room_configs(room_id TEXT, config_domain TEXT, config_data TEXT, updated_at TEXT, PRIMARY KEY(room_id, config_domain)); BEGIN IMMEDIATE; SELECT CASE WHEN (SELECT version FROM schema_version)={{ schema_expected }} THEN 1 ELSE RAISE(ABORT,\"SCHEMA_VERSION_MISMATCH\") END; SELECT CASE WHEN COALESCE(strftime(\"%s\",\"now\") - (SELECT last_ts FROM write_guard WHERE domain=\"vacuum_control\"), 9999) >= 2 THEN 1 ELSE RAISE(ABORT,\"WRITE_RATE_LIMIT\") END; UPDATE room_configs SET config_data = json_set(config_data, \"$.last_cleaned\", datetime(\"now\"), \"$.needs_cleaning\", 0), updated_at = datetime(\"now\") WHERE room_id=\"{{ room_id }}\" AND config_domain=\"vacuum_control\"; INSERT OR REPLACE INTO write_guard(domain,last_ts) VALUES(\"vacuum_control\", strftime(\"%s\",\"now\")); COMMIT;" 2>/dev/null || echo "SQLite operation failed" >&2
    '

# Recorder policy to exclude SQL sensors from history (prevent database bloat)
recorder:
  exclude:
    entity_globs:
      - sensor.room_configs_*
      - sensor.rooms_needing_cleaning
      - sensor.appdaemon_health_raw
      - sensor.appdaemon_test_raw
      - sensor.appdaemon_health_direct_test
