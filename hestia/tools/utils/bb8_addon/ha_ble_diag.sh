#!/usr/bin/env bash
# Sphero BB-8 BLE Diagnostics Script for Home Assistant Add-on
# Collects end-to-end BLE + environment diagnostics without moving the robot
set -Eeuo pipefail

# Default values
ADAPTER="hci0"
MAC=""
NAME=""
SCAN_SEC=6

# Script metadata
SCRIPT_VERSION="1.0.0"
TIMESTAMP=$(date -u +%Y%m%dT%H%M%SZ)
BASE_DIR="/config/reports/diagnostics/HA-BLE"
DIAG_DIR="${BASE_DIR}/${TIMESTAMP}"
TARBALL_PATH="${BASE_DIR}/ha_ble_diag_${ADAPTER}_${TIMESTAMP}.tar.gz"

# Logging functions
log() { echo "[$(date -u +%H:%M:%S)] $*" >&2; }
log_ok() { echo "[$(date -u +%H:%M:%S)] ✓ $*" >&2; }
log_warn() { echo "[$(date -u +%H:%M:%S)] ⚠ $*" >&2; }
log_error() { echo "[$(date -u +%H:%M:%S)] ✗ $*" >&2; }

# Exit handler
cleanup() {
    local exit_code=$?
    if [[ $exit_code -ne 0 ]]; then
        log_error "Script failed with exit code $exit_code"
        echo "FAIL: Diagnostics collection failed at step: ${CURRENT_STEP:-unknown}"
    fi
}
trap cleanup EXIT

# Usage function
usage() {
    cat << EOF
Usage: $0 -m|--mac MAC_ADDRESS [OPTIONS]

Collect end-to-end BLE + environment diagnostics for Sphero BB-8 control.

Required:
  -m, --mac MAC        BB-8 MAC address (e.g., AA:BB:CC:DD:EE:FF)

Optional:
  -a, --adapter ADAPTER   Bluetooth adapter (default: hci0)
  -n, --name NAME         BB-8 device name (for scanning)
  -t, --scan-sec SECONDS  BLE scan duration in seconds (default: 6)
  -h, --help              Show this help

Output: Creates tarball at reports/diagnostics/HA-BLE/
EOF
}

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -a|--adapter)
            ADAPTER="$2"
            shift 2
            ;;
        -m|--mac)
            MAC="$2"
            shift 2
            ;;
        -n|--name)
            NAME="$2"
            shift 2
            ;;
        -t|--scan-sec)
            SCAN_SEC="$2"
            shift 2
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        *)
            log_error "Unknown option: $1"
            usage
            exit 1
            ;;
    esac
done

# Validate required arguments
if [[ -z "$MAC" ]]; then
    log_error "MAC address is required (-m|--mac)"
    usage
    exit 1
fi

# Validate MAC format
if ! [[ "$MAC" =~ ^([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}$ ]]; then
    log_error "Invalid MAC address format: $MAC"
    exit 1
fi

# Detect Python
detect_python() {
    if [[ -x "/opt/venv/bin/python" ]]; then
        echo "/opt/venv/bin/python"
    elif command -v python3 >/dev/null 2>&1; then
        echo "python3"
    else
        log_error "No Python found"
        return 1
    fi
}

PYTHON=$(detect_python)
log "Using Python: $PYTHON"

# Create output directory
log "Creating diagnostics directory: $DIAG_DIR"
mkdir -p "$DIAG_DIR"

# Initialize summary
cat > "$DIAG_DIR/summary.md" << EOF
# Sphero BB-8 BLE Diagnostics Report

**Generated:** $(date -u -Iseconds)  
**Script Version:** $SCRIPT_VERSION  
**Adapter:** $ADAPTER  
**Target MAC:** $MAC  
**Target Name:** ${NAME:-"(not specified)"}  
**Scan Duration:** ${SCAN_SEC}s  

## Summary

EOF

# Create README
cat > "$DIAG_DIR/README.md" << EOF
# BB-8 BLE Diagnostics Artifacts

This directory contains diagnostic information collected for Sphero BB-8 BLE troubleshooting.

## Files

- **summary.md** - Human-readable summary of diagnostics
- **environment.txt** - System environment information  
- **capabilities.txt** - Container capabilities and permissions
- **bluez.txt** - BlueZ stack and adapter information
- **lib_versions.json** - Python library versions
- **mqtt_diag.json** - MQTT connectivity test results
- **ble_scan.ndjson** - BLE scan results in NDJSON format
- **presence.log** - BB-8 presence scanner output
- **gatt.log** - GATT service scan output  
- **spherov2_probe.json** - Spherov2 connection test results

## Usage

Generated by: ha_ble_diag.sh v$SCRIPT_VERSION
Timestamp: $TIMESTAMP
Target: $MAC ($ADAPTER)
EOF

# Function to run step with error handling
run_step() {
    local step_name="$1"
    local step_func="$2"
    
    CURRENT_STEP="$step_name"
    log "Running step: $step_name"
    
    if "$step_func"; then
        log_ok "$step_name completed"
        echo "- ✓ $step_name" >> "$DIAG_DIR/summary.md"
        return 0
    else
        log_warn "$step_name failed (continuing)"
        echo "- ⚠ $step_name (failed)" >> "$DIAG_DIR/summary.md"
        return 1
    fi
}

# Step 1: System & container context
collect_system_info() {
    {
        echo "=== System Information ==="
        uname -a || true
        echo
        
        echo "=== OS Release ==="
        cat /etc/os-release || true
        echo
        
        echo "=== User Context ==="
        id || true
        echo
        
        echo "=== Disk Usage ==="
        df -h || true
        echo
        
        echo "=== Memory Usage ==="
        free -m || true
        echo
        
        echo "=== D-Bus Status ==="
        if test -S /run/dbus/system_bus_socket; then
            echo "D-Bus system socket: present"
        else
            echo "D-Bus system socket: missing"
        fi
        ls -l /run/dbus/ 2>/dev/null || echo "D-Bus directory not accessible"
        echo
    } > "$DIAG_DIR/environment.txt"
    
    # Capabilities
    {
        echo "=== Process Capabilities ==="
        grep CapEff /proc/1/status || echo "Cannot read capabilities"
        echo
        
        echo "=== Process Status ==="
        grep -E "(Name|State|Uid|Gid)" /proc/1/status || true
    } > "$DIAG_DIR/capabilities.txt"
}

# Step 2: BlueZ stack & adapter
collect_bluez_info() {
    {
        echo "=== BlueZ Versions ==="
        bluetoothctl --version 2>/dev/null || bluetoothctl -v 2>/dev/null || echo "bluetoothctl not available"
        bluetoothd --version 2>/dev/null || bluetoothd -v 2>/dev/null || echo "bluetoothd version not available"
        echo
        
        echo "=== RF Kill Status ==="
        rfkill list || echo "rfkill not available"
        echo
        
        echo "=== HCI Configuration ==="
        hciconfig -a "$ADAPTER" || echo "hciconfig failed for $ADAPTER"
        echo
        
        echo "=== Bluetooth Controller Info ==="
        timeout 10 bluetoothctl show 2>/dev/null || echo "bluetoothctl show failed or timed out"
        echo
        
        echo "=== Bluetooth Service Status ==="
        systemctl is-active bluetooth 2>/dev/null || echo "Cannot check bluetooth service status"
    } > "$DIAG_DIR/bluez.txt"
}

# Step 3: Python runtime & libs
collect_python_info() {
    local versions_file="$DIAG_DIR/lib_versions.json"
    
    # Get Python version
    local python_version
    python_version=$($PYTHON --version 2>&1)
    
    # Create Python script to check library versions
    cat > "$DIAG_DIR/check_versions.py" << 'EOF'
import json
import sys

def get_version(module_name):
    try:
        module = __import__(module_name)
        if hasattr(module, '__version__'):
            return module.__version__
        elif hasattr(module, 'version'):
            return module.version
        else:
            return "unknown"
    except ImportError:
        return "not_installed"
    except Exception as e:
        return f"error: {str(e)}"

versions = {
    "python": sys.version,
    "bleak": get_version("bleak"),
    "spherov2": get_version("spherov2"),
    "paho_mqtt": get_version("paho.mqtt")
}

print(json.dumps(versions, indent=2))
EOF
    
    $PYTHON "$DIAG_DIR/check_versions.py" > "$versions_file" 2>/dev/null || {
        echo '{"error": "Failed to collect library versions"}' > "$versions_file"
    }
    
    rm -f "$DIAG_DIR/check_versions.py"
    log "Python: $python_version"
}

# Step 4: MQTT reachability
test_mqtt_connectivity() {
    local mqtt_file="$DIAG_DIR/mqtt_diag.json"
    
    cat > "$DIAG_DIR/mqtt_test.py" << 'EOF'
import json
import sys
import time
import threading
from datetime import datetime

try:
    import paho.mqtt.client as mqtt
except ImportError:
    result = {"error": "paho-mqtt not available", "timestamp": datetime.utcnow().isoformat()}
    print(json.dumps(result))
    sys.exit(0)

result = {
    "mqtt_available": True,
    "connect_success": False,
    "publish_success": False,
    "subscribe_success": False,
    "round_trip_success": False,
    "timestamp": datetime.utcnow().isoformat(),
    "error": None
}

received_message = threading.Event()

def on_connect(client, userdata, flags, rc):
    if rc == 0:
        result["connect_success"] = True
        # Subscribe to our test topic
        client.subscribe("bb8/diag/ping")
    else:
        result["error"] = f"Connection failed with code {rc}"

def on_message(client, userdata, msg):
    if msg.topic == "bb8/diag/ping":
        result["subscribe_success"] = True
        result["round_trip_success"] = True
        received_message.set()

def on_publish(client, userdata, mid):
    result["publish_success"] = True

try:
    client = mqtt.Client()
    client.on_connect = on_connect
    client.on_message = on_message
    client.on_publish = on_publish
    
    # Connect to internal broker
    client.connect("core-mosquitto", 1883, 10)
    client.loop_start()
    
    # Wait for connection
    time.sleep(1)
    
    if result["connect_success"]:
        # Publish test message
        msg_info = client.publish("bb8/diag/ping", "diagnostic_ping", retain=True)
        
        # Wait for round-trip
        received_message.wait(timeout=5)
    
    client.loop_stop()
    client.disconnect()
    
except Exception as e:
    result["error"] = str(e)

print(json.dumps(result, indent=2))
EOF
    
    $PYTHON "$DIAG_DIR/mqtt_test.py" > "$mqtt_file" 2>/dev/null || {
        echo '{"error": "MQTT test script failed", "timestamp": "'$(date -u -Iseconds)'"}' > "$mqtt_file"
    }
    
    rm -f "$DIAG_DIR/mqtt_test.py"
    
    # Log result
    if grep -q '"round_trip_success": true' "$mqtt_file"; then
        log_ok "MQTT connectivity test passed"
    else
        log_warn "MQTT connectivity test failed"
    fi
}

# Step 5: BLE scan
perform_ble_scan() {
    local scan_file="$DIAG_DIR/ble_scan.ndjson"
    
    cat > "$DIAG_DIR/ble_scan.py" << EOF
import json
import sys
import asyncio
from datetime import datetime

try:
    from bleak import BleakScanner
except ImportError:
    print('{"error": "bleak not available", "timestamp": "' + datetime.utcnow().isoformat() + '"}')
    sys.exit(0)

async def scan_devices():
    target_mac = "${MAC}".upper()
    target_name = "${NAME}" if "${NAME}" else None
    scan_seconds = ${SCAN_SEC}
    
    found_target_mac = False
    found_target_name = False
    device_count = 0
    
    print(f"# Starting BLE scan for {scan_seconds}s", file=sys.stderr)
    
    def detection_callback(device, advertisement_data):
        nonlocal found_target_mac, found_target_name, device_count
        device_count += 1
        
        # Check if this is our target
        if device.address.upper() == target_mac:
            found_target_mac = True
        
        if target_name and device.name and target_name.lower() in device.name.lower():
            found_target_name = True
        
        # Create NDJSON record
        record = {
            "timestamp": datetime.utcnow().isoformat(),
            "address": device.address,
            "name": device.name,
            "rssi": advertisement_data.rssi,
            "local_name": advertisement_data.local_name,
            "service_uuids": [str(uuid) for uuid in advertisement_data.service_uuids],
            "manufacturer_data": {str(k): list(v) for k, v in advertisement_data.manufacturer_data.items()},
            "is_target_mac": device.address.upper() == target_mac,
            "is_target_name": target_name and device.name and target_name.lower() in device.name.lower() if target_name else False
        }
        print(json.dumps(record))
    
    try:
        scanner = BleakScanner(detection_callback)
        await scanner.start()
        await asyncio.sleep(scan_seconds)
        await scanner.stop()
        
        # Summary record
        summary = {
            "scan_complete": True,
            "timestamp": datetime.utcnow().isoformat(),
            "scan_duration": scan_seconds,
            "devices_found": device_count,
            "target_mac_found": found_target_mac,
            "target_name_found": found_target_name,
            "target_mac": target_mac,
            "target_name": target_name
        }
        print(json.dumps(summary), file=sys.stderr)
        
    except Exception as e:
        error_record = {
            "error": "BLE scan failed",
            "details": str(e),
            "timestamp": datetime.utcnow().isoformat()
        }
        print(json.dumps(error_record))

if __name__ == "__main__":
    asyncio.run(scan_devices())
EOF
    
    $PYTHON "$DIAG_DIR/ble_scan.py" > "$scan_file" 2>&1 || {
        echo '{"error": "BLE scan script failed", "timestamp": "'$(date -u -Iseconds)'"}' > "$scan_file"
    }
    
    rm -f "$DIAG_DIR/ble_scan.py"
    
    # Check if target was found
    if grep -q '"is_target_mac": true' "$scan_file"; then
        log_ok "Target MAC $MAC found in BLE scan"
    else
        log_warn "Target MAC $MAC not found in BLE scan"
    fi
}

# Step 6: Targeted presence and GATT checks
run_presence_gatt_checks() {
    # BB-8 presence scanner
    if $PYTHON -m bb8_core.bb8_presence_scanner --help >/dev/null 2>&1; then
        log "Running bb8_presence_scanner"
        timeout 30 $PYTHON -m bb8_core.bb8_presence_scanner --adapter "$ADAPTER" --mac "$MAC" 2>&1 | tee "$DIAG_DIR/presence.log" || {
            # Try without arguments
            timeout 30 $PYTHON -m bb8_core.bb8_presence_scanner 2>&1 | tee "$DIAG_DIR/presence.log" || {
                echo "bb8_presence_scanner failed or timed out" > "$DIAG_DIR/presence.log"
            }
        }
    else
        echo "bb8_presence_scanner module not available" > "$DIAG_DIR/presence.log"
    fi
    
    # GATT scanner
    if $PYTHON -m bb8_core.scan_bb8_gatt --help >/dev/null 2>&1; then
        log "Running scan_bb8_gatt"
        timeout 30 $PYTHON -m bb8_core.scan_bb8_gatt --adapter "$ADAPTER" --mac "$MAC" 2>&1 | tee "$DIAG_DIR/gatt.log" || {
            # Try without arguments
            timeout 30 $PYTHON -m bb8_core.scan_bb8_gatt 2>&1 | tee "$DIAG_DIR/gatt.log" || {
                echo "scan_bb8_gatt failed or timed out" > "$DIAG_DIR/gatt.log"
            }
        }
    else
        echo "scan_bb8_gatt module not available" > "$DIAG_DIR/gatt.log"
    fi
}

# Step 7: Spherov2 minimal connect
test_spherov2_connection() {
    local spherov2_file="$DIAG_DIR/spherov2_probe.json"
    
    cat > "$DIAG_DIR/spherov2_test.py" << EOF
import json
import sys
import asyncio
from datetime import datetime

result = {
    "spherov2_available": False,
    "connect_ok": False,
    "battery_pct": None,
    "error": None,
    "timestamp": datetime.utcnow().isoformat()
}

try:
    from spherov2 import scanner
    from spherov2.sphero_edu import SpheroEduAPI
    result["spherov2_available"] = True
    
    async def test_connection():
        try:
            # Create API instance
            droid = SpheroEduAPI()
            
            # Connect with timeout
            print("Attempting connection...", file=sys.stderr)
            await asyncio.wait_for(droid.connect("${MAC}"), timeout=5.0)
            result["connect_ok"] = True
            print("Connected successfully", file=sys.stderr)
            
            # Get battery level
            try:
                battery = await droid.get_battery_percentage()
                result["battery_pct"] = battery
                print(f"Battery: {battery}%", file=sys.stderr)
            except Exception as e:
                result["error"] = f"Battery read failed: {str(e)}"
            
            # Disconnect immediately
            await droid.disconnect()
            print("Disconnected", file=sys.stderr)
            
        except asyncio.TimeoutError:
            result["error"] = "Connection timeout"
        except Exception as e:
            result["error"] = f"Connection failed: {str(e)}"
    
    asyncio.run(test_connection())
    
except ImportError:
    result["error"] = "spherov2 not available"
except Exception as e:
    result["error"] = f"Unexpected error: {str(e)}"

print(json.dumps(result, indent=2))
EOF
    
    $PYTHON "$DIAG_DIR/spherov2_test.py" > "$spherov2_file" 2>/dev/null || {
        echo '{"error": "Spherov2 test script failed", "timestamp": "'$(date -u -Iseconds)'"}' > "$spherov2_file"
    }
    
    rm -f "$DIAG_DIR/spherov2_test.py"
    
    # Log result
    if grep -q '"connect_ok": true' "$spherov2_file"; then
        log_ok "Spherov2 connection test passed"
    else
        log_warn "Spherov2 connection test failed"
    fi
}

# Main execution
main() {
    log "Starting BB-8 BLE diagnostics collection"
    log "Target: $MAC on adapter $ADAPTER"
    log "Output directory: $DIAG_DIR"
    
    # Run all diagnostic steps
    run_step "System Information" collect_system_info
    run_step "BlueZ Information" collect_bluez_info  
    run_step "Python Libraries" collect_python_info
    run_step "MQTT Connectivity" test_mqtt_connectivity
    run_step "BLE Scan" perform_ble_scan
    run_step "Presence/GATT Checks" run_presence_gatt_checks
    run_step "Spherov2 Connection Test" test_spherov2_connection
    
    # Finalize summary
    {
        echo
        echo "## Configuration"
        echo "- **Adapter:** $ADAPTER"
        echo "- **Target MAC:** $MAC"
        echo "- **Target Name:** ${NAME:-"(not specified)"}"
        echo "- **Scan Duration:** ${SCAN_SEC}s"
        echo "- **Python:** $($PYTHON --version 2>&1)"
        echo
        echo "## Files Generated"
        echo "$(ls -la "$DIAG_DIR" | tail -n +2 | awk '{print "- " $9 " (" $5 " bytes)"}')"
        echo
        echo "---"
        echo "*Diagnostics completed at $(date -u -Iseconds)*"
    } >> "$DIAG_DIR/summary.md"
    
    # Create tarball
    log "Creating tarball: $TARBALL_PATH"
    cd "$BASE_DIR"
    tar -czf "$TARBALL_PATH" -C "$BASE_DIR" "$(basename "$DIAG_DIR")"
    
    log_ok "Diagnostics collection completed"
    echo "*** DIAG TAR: $TARBALL_PATH ***"
    echo "OK: $TARBALL_PATH"
}

# Run main function
main "$@"