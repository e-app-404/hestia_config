# Home Assistant Error Patterns and Resolution Guide
# This file documents common error patterns in Home Assistant and their fixes
# Used by diagnostic tools and documentation

patterns:
  - name: "template_variable_undefined"
    category: "jinja_template"
    description: "Template errors when variables don't exist or are undefined"
    error_format: "UndefinedError: 'variable_name' is undefined"
    symptoms:
      - "Template errors in Home Assistant logs"
      - "Sensors showing 'unavailable' state"
      - "Automations failing to execute"
    root_causes:
      - "Missing existence checks before using template variables"
      - "Improper Jinja whitespace control leading to empty strings"
      - "Using template functions on undefined variables"
    solution:
      - "Add defensive checks: {% if trigger.to_state is not none %}"
      - "Use whitespace control: {%- set var = value -%}"
      - "Check state validity: {{ raw not in ['unknown','unavailable',''] }}"
    examples:
      bad: |
        value_template: "{{ trigger.to_state.state | abs }}"
      good: |
        value_template: >-
          {%- set state = trigger.to_state -%}
          {{ state is not none and state.state not in ['unknown','unavailable',''] 
             and state.state | abs or 0 }}
    references:
      - "Home Assistant Template Documentation"
      - "Jinja2 Template Documentation"
      - "ADR-0020: Template Error Patterns"

  - name: "backup_agent_upload_failure"
    category: "backup"
    description: "Backup uploads failing to configured remote locations like Synology NAS"
    error_format: "backup could not be uploaded to the configured locations [location]"
    symptoms:
      - "Automatic backup upload failed notifications"
      - "Backup agent showing failed uploads in storage"
      - "Synology NAS backup errors"
      - "Backup warning notifications in Home Assistant"
    root_causes:
      - "Multi-factor authentication enabled on NAS user account"
      - "Backup target path does not exist or lacks write permissions"
      - "Network connectivity issues or firewall blocking access"
      - "Insufficient storage space on backup destination"
      - "Expired or invalid authentication credentials"
      - "NAS service disabled or configuration changed"
    solution:
      - "Disable MFA for backup service account on NAS"
      - "Verify backup path exists and has proper permissions"
      - "Test network connectivity and API access"
      - "Reconfigure Home Assistant backup integration"
    examples:
      bad: |
        # .storage/backup showing failed uploads
        {
          "backup_id": "abc123",
          "failed_agent_ids": ["synology_dsm.2330RLRDXJ1F8"],
          "failed_folders": []
        }
      good: |
        # .storage/backup with successful uploads
        {
          "backup_id": "abc123",
          "failed_agent_ids": [],
          "failed_folders": []
        }
    resolution_steps:
      - "Run backup validation: hestia/tools/backup_validator.sh"
      - "Check NAS user MFA and privilege settings"
      - "Verify backup path permissions and disk space"
      - "Test API connectivity to backup destination"
      - "Reconfigure integration if authentication fails"
    tooling:
      - "hestia/tools/backup_validator.sh - comprehensive backup agent testing"
      - "jq '.data.backups[] | select(.failed_agent_ids | length > 0)' /config/.storage/backup"

  - name: "entity_registry_duplication"
    category: "entity_registry"
    description: "Duplicate entities with _2 suffix from device re-registration"
    error_format: "Multiple entities with same name but different unique_id patterns"
    symptoms:
      - "Entities appearing with _2, _3 suffixes in entity registry"
      - "Original entities showing as 'unavailable' with 'restored: true'"
      - "Duplicate mobile app or integration device registrations"
      - "Entity conflicts after device re-pairing or integration reload"
    root_causes:
      - "Mobile app re-registration creating new device with different device_id"
      - "Integration reload without proper cleanup of old entities"
      - "Device pairing conflicts with existing entity unique_ids"
      - "Orphaned entities from removed integrations not cleaned up"
      - "Entity restore state conflicts with new registrations"
    solution:
      - "Remove duplicate entities via Developer Tools > Entities"
      - "For unavailable base + active suffixed: disable base, rename suffixed to take base entity_id"
      - "Clean up orphaned config entries from removed integrations"
      - "Disable old entities before re-registering devices"
      - "Use entity registry cleanup tools to remove suffixed duplicates"
    examples:
      bad: |
        # Entity registry showing duplicates
        sensor.ephone_uk_activity (unavailable, restored: true)
        sensor.ephone_uk_activity_2 (active, new device_id)
      good: |
        # Clean entity registry
        sensor.ephone_uk_activity (active, single registration)
    resolution_steps:
      - "Identify duplicate entities: grep '_2.*entity_id' .storage/core.entity_registry"
      - "Find associated config entries with different device_ids"
      - "For unavailable base + active suffixed pattern:"
      - "  1. Disable the unavailable base entity"
      - "  2. Change suffixed entity_id to take over base entity_id (via Developer Tools)"
      - "  3. Verify the renamed entity maintains functionality"
      - "Clean up orphaned device registrations"
      - "Restart Home Assistant to refresh entity states"
    tooling:
      - "Developer Tools > Entities - search for _2, _3 suffixes"
      - "jq '.data.entities[] | select(.entity_id | contains(\"_2\"))' .storage/core.entity_registry"

  - name: "blueprint_path_resolution"
    category: "automation_blueprint"
    description: "Blueprint loading errors due to incorrect path references"
    error_format: "Unable to find [path]/blueprint.yaml"
    symptoms:
      - "Blueprint loading failures in Home Assistant"
      - "Automations showing as 'unknown' or failing to load"
      - "Configuration validation errors for blueprint paths"
    root_causes:
      - "Incorrect blueprint path references in automation files"
      - "Missing 'hestia/' prefix in blueprint paths"
      - "Blueprint files moved but automation paths not updated"
    solution:
      - "Use canonical blueprint path: hestia/library/blueprints/"
      - "Verify blueprint file exists at referenced path"
      - "Update all automation files with correct blueprint paths"
    examples:
      bad: |
        use_blueprint:
          path: library/blueprints/sensor-light.yaml
      good: |
        use_blueprint:
          path: hestia/library/blueprints/sensor-light.yaml
    resolution_steps:
      - "Search for incorrect blueprint references: grep -r 'path: library/blueprints/' **/*.yaml"
      - "Verify blueprint files exist: ls hestia/library/blueprints/"
      - "Replace incorrect paths with canonical paths"
      - "Validate Home Assistant configuration after changes"
    references:
      - "ADR-0016: Canonical Workspace Structure"

  - name: "recorder_invalid_action_parameter"
    category: "automation_action"
    description: "Invalid parameters used with Home Assistant recorder actions"
    error_format: "extra keys not allowed @ data['parameter_name']"
    symptoms:
      - "Automation execution failures with recorder actions"
      - "Error messages about extra keys not allowed"
      - "Script execution errors in recorder actions"
    root_causes:
      - "Using parameters valid for one recorder action with another action"
      - "Incorrect parameter names or deprecated parameters"
      - "Mixing recorder.purge and recorder.purge_entities parameters"
    solution:
      - "Use correct parameters for each recorder action"
      - "Remove invalid parameters from action data"
      - "Consult Home Assistant documentation for valid parameters"
    examples:
      bad: |
        action: recorder.purge_entities
        data:
          keep_days: 0
          entity_id: sensor.example
          apply_filter: true  # Invalid for purge_entities
      good: |
        action: recorder.purge_entities
        data:
          keep_days: 0
          entity_id: sensor.example
        # OR use recorder.purge with apply_filter
        action: recorder.purge
        data:
          keep_days: 7
          apply_filter: true
    resolution_steps:
      - "Identify the failing automation from error logs"
      - "Check Home Assistant documentation for valid action parameters"
      - "Remove invalid parameters from automation action data"
      - "Test automation execution after fix"
    references:
      - "Home Assistant Recorder Integration Documentation"

  - name: "shell_command_path_error"
    category: "shell_command"
    description: "Shell command execution failures due to incorrect file paths"
    error_format: "Error running command: `command`, return code: 127"
    symptoms:
      - "Shell command returning exit code 127 (command not found)"
      - "Scripts failing to execute from Home Assistant"
      - "File not found errors in shell command execution"
    root_causes:
      - "Incorrect file paths in shell command configuration"
      - "Scripts moved but configuration not updated"
      - "Missing executable permissions on script files"
    solution:
      - "Use correct canonical paths to script files"
      - "Verify script files exist at specified locations"
      - "Ensure scripts have executable permissions"
    examples:
      bad: |
        shell_command:
          git_push: "bash -lc '/config/tools/script.sh'"
      good: |
        shell_command:
          git_push: "bash -lc '/config/hestia/tools/script.sh'"
    resolution_steps:
      - "Check if script file exists at the specified path"
      - "Update path to use canonical workspace structure"
      - "Verify script has executable permissions: chmod +x script.sh"
      - "Test shell command execution from Home Assistant"
    references:
      - "ADR-0016: Canonical Workspace Structure"

  - name: "missing_integration_reference"
    category: "integration_loading"
    description: "WebSocket errors when frontend tries to access non-existent integrations"
    error_format: "Integration 'integration_name' not found"
    symptoms:
      - "WebSocket API errors in Home Assistant logs"
      - "Frontend elements failing to load"
      - "Unknown error messages in browser console"
    root_causes:
      - "Custom integrations removed but still referenced in frontend"
      - "Cached references to removed integrations"
      - "UI elements trying to access non-existent integration manifests"
    solution:
      - "Clear browser cache and restart Home Assistant"
      - "Remove any lingering configuration references"
      - "Check for custom UI elements referencing the integration"
    examples:
      symptoms: |
        homeassistant.loader.IntegrationNotFound: Integration 'icloud3' not found.
      resolution: |
        1. Clear browser cache
        2. Check custom_components directory
        3. Search configuration files for references
        4. Restart Home Assistant
    resolution_steps:
      - "Identify the missing integration from error logs"
      - "Search configuration files for any references: grep -r 'integration_name' ."
      - "Clear browser cache and Home Assistant frontend cache"
      - "Restart Home Assistant to clear cached references"
    references:
      - "Home Assistant Integration Loading Documentation"

  - name: "command_line_curl_ssl_error"
    category: "command_line_sensor"
    description: "Command line sensors failing due to SSL/TLS connection issues with curl"
    error_format: "Command failed (with return code 35): bash -lc '.*curl.*'"
    symptoms:
      - "Command line sensors showing 'unknown' or 'unavailable' states"
      - "Return code 35 errors in Home Assistant logs"
      - "SSL connect error messages in command line integration logs"
      - "Intermittent sensor failures"
    root_causes:
      - "SSL/TLS handshake failures with remote servers"
      - "Certificate validation issues or expired certificates"
      - "Network connectivity problems during SSL negotiation"
      - "Cloudflare or proxy SSL configuration issues"
      - "Insufficient error handling in curl commands"
    solution:
      - "Add error handling with fallback values using || echo 'fallback'"
      - "Redirect stderr to /dev/null to suppress SSL noise: 2>/dev/null"
      - "Use appropriate fallback values in value_template"
      - "Consider adding curl SSL options like --insecure for internal services (with caution)"
    examples:
      bad: |
        command: >-
          bash -lc '
            set -eo pipefail
            curl -s -o /dev/null -w "%{http_code}" https://example.com/api | tr -d "\n"
          '
        value_template: "{{ value | default('unknown') | trim }}"
      good: |
        command: >-
          bash -lc '
            set -eo pipefail
            curl -s -o /dev/null -w "%{http_code}" https://example.com/api 2>/dev/null | tr -d "\n" || echo "000"
          '
        value_template: "{{ value | default('000') | trim }}"
    resolution_steps:
      - "Identify the failing command from error logs"
      - "Add error handling to curl commands with || echo 'fallback_value'"
      - "Redirect stderr to /dev/null to suppress SSL error noise"
      - "Update value_template to use appropriate default values"
      - "Test manually: bash -lc 'your_curl_command || echo fallback'"
      - "Consider certificate verification if using internal services"
    prevention_strategies:
      - "Always include error handling in curl-based command line sensors"
      - "Use appropriate timeouts with --connect-timeout and --max-time"
      - "Monitor SSL certificate expiration dates"
      - "Test commands in various network conditions"
    tooling:
      detector: "grep -r 'Command failed.*return code 35' /config/home-assistant.log"
      validator: "Test curl commands manually with verbose output: curl -v"
    references:
      - "Home Assistant Command Line Integration Documentation"
      - "curl manual and error codes documentation"
      - "SSL/TLS troubleshooting guides"

  - name: "yaml_duplicate_key_error"
    category: "yaml_configuration"
    description: "YAML parsing errors due to duplicate keys in configuration files"
    error_format: "YAML file [path] contains duplicate key \"[key]\". Check lines [n] and [m]"
    symptoms:
      - "YAML parsing warnings in Home Assistant logs"
      - "Configuration sections not loading as expected"
      - "Duplicate key warnings during startup"
    root_causes:
      - "Multiple sections with the same key in a single YAML file"
      - "Copy-paste errors creating duplicate configuration blocks"
      - "Legacy cache files accidentally being loaded"
      - "Incorrect file includes or symlinks"
    solution:
      - "Merge duplicate sections into a single configuration block"
      - "Remove redundant key definitions"
      - "Check for accidental file inclusions from cache directories"
      - "Validate YAML structure before deployment"
    examples:
      bad: |
        input_boolean:
          setting_one: true
        # Later in same file...
        input_boolean:
          setting_two: false
      good: |
        input_boolean:
          setting_one: true
          setting_two: false
    resolution_steps:
      - "Identify the file and line numbers from error message"
      - "Open the file and locate the duplicate key sections"
      - "Merge the configurations into a single block"
      - "Remove any redundant or conflicting definitions"
      - "Validate YAML syntax after changes"
    references:
      - "Home Assistant Configuration Documentation"
      - "YAML Specification"

  - name: "yaml_heredoc_parsing_error"
    category: "yaml_configuration"
    description: "YAML parsing errors when using heredoc syntax within folded scalars"
    error_format: "while scanning a simple key...could not find expected ':'"
    symptoms:
      - "Configuration loading failures with cryptic YAML parsing errors"
      - "Shell command configurations failing to load"
      - "Error messages pointing to line numbers with colon expectations"
      - "Home Assistant failing to start due to configuration syntax errors"
    root_causes:
      - "Using heredoc syntax (<<\"DELIMITER\") within YAML folded scalar blocks (>-)"
      - "Complex shell commands with embedded quotes conflicting with YAML parsing"
      - "Multi-line SQL or shell scripts incorrectly formatted in YAML"
      - "YAML parser unable to handle nested quoting structures"
    solution:
      - "Convert from folded scalar (>-) to literal scalar (|) block style"
      - "Eliminate heredoc syntax and use inline SQL with proper escaping"
      - "Escape all internal quotes within the command string"
      - "Use single-line format for complex SQL operations"
    examples:
      bad: |
        shell_command:
          update_room_config: >-
            /bin/sh -c 'sqlite3 /config/room_database.db <<"SQL"
            PRAGMA journal_mode=WAL;
            UPDATE table SET data = "{{ value }}";
        SQL'
      good: |
        shell_command:
          update_room_config: |
            /bin/sh -c 'sqlite3 /config/room_database.db "PRAGMA journal_mode=WAL; UPDATE table SET data = \"{{ value }}\";"'
    resolution_steps:
      - "Identify the problematic YAML file from error message line numbers"
      - "Locate shell commands or complex multi-line strings using >- folded scalars"
      - "Convert folded scalar (>-) to literal scalar (|) block style"
      - "Remove heredoc syntax and inline the SQL/shell commands"
      - "Escape all internal quotes: \" becomes \\\" within the command string"
      - "Test configuration loading with: /config/bin/config-health /config"
      - "Verify shell commands execute properly after YAML fixes"
    prevention_strategies:
      - "Use literal scalar (|) for complex shell commands instead of folded scalar (>-)"
      - "Avoid heredoc syntax within YAML; use inline commands with proper escaping"
      - "Test YAML parsing after adding complex shell commands"
      - "Consider external script files for very complex multi-line operations"
    tooling:
      detector: "Look for error patterns: 'while scanning a simple key' + 'could not find expected':'"
      validator: "/config/bin/config-health /config - validates Home Assistant YAML configuration"
      test_yaml: "python -c \"import yaml; yaml.safe_load(open('file.yaml'))\" - test YAML parsing"
    references:
      - "YAML Specification - Block Scalar Styles"
      - "Home Assistant Shell Command Integration Documentation"
      - "ADR-0018: Configuration Normalization Standards"

  - name: "blueprint_loading_error"
    category: "automation_blueprint"
    description: "Blueprint loading failures due to incorrect file paths or missing files"
    error_format: "Failed to load blueprint: Unable to find [path]"
    symptoms:
      - "Blueprint automation generation failures"
      - "Blueprint path resolution errors in logs"
      - "Automations showing as unavailable or failing to load"
    root_causes:
      - "Incorrect blueprint file paths in blueprint matrix or automation files"
      - "Missing hestia/ prefix in blueprint paths"
      - "Blueprint files moved but references not updated"
      - "Typos in blueprint file paths"
    solution:
      - "Use correct canonical blueprint paths with hestia/ prefix"
      - "Verify blueprint files exist at referenced locations"
      - "Update blueprint matrix with correct paths"
      - "Fix typos in blueprint references"
    examples:
      bad: |
        # Blueprint matrix with incorrect paths
        - core_executor: "library/blueprints/sensor-light.yaml"
        - link_entities: "library/blueprints/ha-blueprint-linked-entities.yaml"
      good: |
        # Blueprint matrix with correct canonical paths
        - core_executor: "hestia/library/blueprints/sensor-light.yaml"
        - link_entities: "hestia/library/blueprints/ha-blueprint-linked-entities.yaml"
    resolution_steps:
      - "Identify the missing blueprint path from error logs"
      - "Verify the blueprint file exists: ls hestia/library/blueprints/"
      - "Update blueprint matrix or automation files with correct paths"
      - "Use canonical hestia/library/blueprints/ prefix for all blueprint references"
      - "Test blueprint loading after path corrections"
    references:
      - "ADR-0016: Canonical Workspace Structure"
      - "Home Assistant Blueprint Documentation"

  - name: "script_selector_configuration_error"
    category: "script_configuration"
    description: "Script configuration errors due to malformed selector syntax in field definitions"
    error_format: "Only one type can be specified. Found for dictionary value @ data['fields']['field_name']['selector']. Got OrderedDict()."
    symptoms:
      - "Scripts showing as 'not active' due to configuration errors"
      - "Script configuration validation failures"
      - "Error messages about dictionary values and multiple types in selectors"
      - "Script field selectors not working properly in UI"
    root_causes:
      - "Using inline dictionary format for selectors: selector: { text: {} }"
      - "YAML parser interpreting nested empty dictionaries as ambiguous types"
      - "Selector syntax not following Home Assistant's expected block format"
      - "Mixed selector syntax formats within the same configuration"
    solution:
      - "Convert inline selector format to explicit block format"
      - "Use proper YAML indentation for selector definitions"
      - "Ensure consistent selector syntax throughout configuration"
      - "Remove unnecessary empty dictionary values"
    examples:
      bad: |
        fields:
          room:
            description: "Room slug (e.g., 'bedroom')"
            required: true
            selector: { text: {} }
      good: |
        fields:
          room:
            description: "Room slug (e.g., 'bedroom')"
            required: true
            selector:
              text:
    resolution_steps:
      - "Identify the problematic script from Home Assistant error messages"
      - "Locate the script configuration file (usually in scripts.yaml or packages/)"
      - "Find the fields section with selector definitions"
      - "Convert inline selector format { type: {} } to block format"
      - "Remove empty dictionary values and use proper YAML block structure"
      - "Test configuration loading with: /config/bin/config-health /config"
      - "Verify script shows as active in Home Assistant UI"
    prevention_strategies:
      - "Always use block format for selector definitions in scripts"
      - "Avoid inline dictionary syntax for complex YAML structures"
      - "Test script configurations after adding new fields"
      - "Use consistent selector syntax patterns across all scripts"
    tooling:
      detector: "Look for error patterns: 'Only one type can be specified' + 'selector' + 'OrderedDict()'"
      validator: "/config/bin/config-health /config - validates Home Assistant configuration"
      script_check: "Check script status in Home Assistant Developer Tools > Services"
    references:
      - "Home Assistant Script Documentation"
      - "Home Assistant Selector Documentation"
      - "YAML Best Practices for Home Assistant"

  - name: "automation_unknown_action_service"
    category: "automation_action"
    description: "Automation failures due to referencing non-existent or misnamed services"
    error_format: "uses an unknown action...has an unknown action: [service_name]"
    symptoms:
      - "Automations showing error status and not executing"
      - "Error messages about unknown actions in automation configuration"
      - "Automation reported as having configuration errors"
      - "Services not found during automation execution"
    root_causes:
      - "Referencing rest_command services that don't exist in configuration"
      - "Typos in service names (e.g., rest_command vs shell_command)"
      - "Services removed or renamed but automation not updated"
      - "Missing integration providing the referenced service"
      - "Incorrect service domain or action name"
    solution:
      - "Verify the correct service exists in Home Assistant configuration"
      - "Update service calls to use correct service names and domains"
      - "Check if service requires specific integration to be installed"
      - "Add missing required parameters for the correct service"
      - "Use Developer Tools > Services to verify available services"
    examples:
      bad: |
        - service: rest_command.room_db_update_config
          data:
            room_id: "bedroom"
            domain: "motion_lighting"
            config_data: "{{ some_data | tojson }}"
      good: |
        - service: shell_command.update_room_config
          data:
            room_id: "bedroom"
            domain: "motion_lighting"
            config_data: "{{ some_data | tojson }}"
            schema_expected: 1
    resolution_steps:
      - "Identify the failing automation from Home Assistant error messages"
      - "Check what services are actually available in configuration"
      - "Verify service domain: rest_command vs shell_command vs other domains"
      - "Update service call to use correct service name and domain"
      - "Add any required parameters that the correct service expects"
      - "Test automation after fixing service references"
      - "Use Developer Tools > Services to verify service is callable"
    prevention_strategies:
      - "Use Developer Tools > Services to verify service names before use"
      - "Keep automation service references in sync with configuration changes"
      - "Document service dependencies and parameter requirements"
      - "Test automations after configuration changes"
    troubleshooting:
      service_discovery: "Developer Tools > Services - browse available services"
      config_check: "/config/bin/config-health /config - validate configuration"
      service_test: "Developer Tools > Services - test service calls manually"
    references:
      - "Home Assistant Services Documentation"
      - "Home Assistant Automation Action Documentation"
      - "Home Assistant Developer Tools Guide"

  - name: "sql_sensor_invalid_configuration_option"
    category: "sql_sensor_configuration"
    description: "SQL sensor configuration errors due to using invalid or deprecated options"
    error_format: "'[option_name]' is an invalid option for 'sql', check: sql->[index]->[option_name]"
    symptoms:
      - "Configuration warnings about invalid SQL sensor options"
      - "SQL sensors not loading with expected configuration"
      - "Home Assistant configuration validation failures"
      - "Integration setup errors for SQL sensors"
    root_causes:
      - "Using scan_interval option which is not supported in individual SQL sensor entries"
      - "Attempting to use sensor platform options in top-level sql configuration"
      - "Mixing deprecated sensor platform syntax with modern sql integration syntax"
      - "Using options from other integrations that don't apply to SQL sensors"
    solution:
      - "Remove invalid options like scan_interval from individual SQL sensor entries"
      - "Use integration-level polling control instead of sensor-level scan_interval"
      - "Consult Home Assistant SQL integration documentation for valid options"
      - "Use automation-based polling for custom update intervals"
    examples:
      bad: |
        sql:
          - name: "My SQL Sensor"
            db_url: sqlite:////config/database.db
            scan_interval: 30  # Invalid option
            query: "SELECT value FROM table;"
            column: value
      good: |
        sql:
          - name: "My SQL Sensor"
            db_url: sqlite:////config/database.db
            query: "SELECT value FROM table;"
            column: value
        # For custom polling, use automation:
        # automation:
        #   - trigger:
        #       platform: time_pattern
        #       seconds: "/30"
        #     action:
        #       service: homeassistant.update_entity
        #       target:
        #         entity_id: sensor.my_sql_sensor
    resolution_steps:
      - "Identify invalid options from Home Assistant configuration warnings"
      - "Check SQL integration documentation for valid configuration options"
      - "Remove scan_interval and other invalid options from sql sensor entries"
      - "Use default 30-second polling or disable polling in Integration settings"
      - "Create automation for custom polling intervals if needed"
      - "Test configuration after removing invalid options"
    prevention_strategies:
      - "Always consult official Home Assistant documentation for integration options"
      - "Don't mix sensor platform syntax with integration syntax"
      - "Use configuration validation to catch invalid options early"
      - "Test SQL sensor configuration after changes"
    valid_options:
      - "name (required): sensor name"
      - "query (required): SQL query string"
      - "column (required): column name for sensor state"
      - "db_url (optional): database connection URL"
      - "unit_of_measurement (optional): sensor unit"
      - "value_template (optional): template for processing value"
      - "unique_id (optional): unique identifier"
      - "device_class (optional): sensor device class"
      - "state_class (optional): sensor state class"
      - "icon (optional): sensor icon template"
      - "picture (optional): sensor picture template"
      - "availability (optional): availability template"
    polling_control:
      - "Default: 30-second automatic polling"
      - "Custom: Disable in Integration settings + use automation"
      - "Integration-level: Settings > Devices & Services > SQL > System Options"
    references:
      - "Home Assistant SQL Integration Documentation"
      - "Home Assistant Integration Configuration Guide"
      - "SQL Sensor Migration Guide (sensor platform to sql integration)"

  - name: "group_set_invalid_parameter"
    category: "automation_action"
    description: "Group.set service errors due to using invalid parameter names"
    error_format: "extra keys not allowed @ data['parameter_name']"
    symptoms:
      - "Automation execution failures with group.set actions"
      - "Error messages about extra keys not allowed in group service calls"
      - "Group creation or modification automations failing"
      - "Persistent automation error notifications"
    root_causes:
      - "Using deprecated or incorrect parameter names like 'default_entity_id'"
      - "Confusion between different group service parameter schemas"
      - "Copy-paste errors from outdated documentation or examples"
      - "Mixing parameters from different Home Assistant versions"
    solution:
      - "Use correct parameter names for group.set service"
      - "Replace 'default_entity_id' with 'object_id' parameter"
      - "Remove group. prefix from entity_id when using object_id"
      - "Consult current Home Assistant group service documentation"
    examples:
      bad: |
        action: group.set
        data:
          default_entity_id: group.unavailable_entities
          entities: []
      good: |
        action: group.set
        data:
          object_id: unavailable_entities
          entities: []
    resolution_steps:
      - "Identify the failing automation from Home Assistant error messages"
      - "Check Home Assistant documentation for current group.set parameters"
      - "Replace 'default_entity_id' with 'object_id' in service calls"
      - "Remove 'group.' prefix from object_id value"
      - "Test automation execution after parameter fix"
    prevention_strategies:
      - "Always consult current Home Assistant documentation for service parameters"
      - "Test service calls in Developer Tools before using in automations"
      - "Avoid copy-paste from outdated examples or forums"
      - "Validate automation configuration after Home Assistant updates"
    tooling:
      detector: "Look for error patterns: 'extra keys not allowed' + group.set service"
      validator: "Developer Tools > Services - test group.set calls with correct parameters"
      config_check: "/config/bin/config-health /config - validate automation configuration"
    references:
      - "Home Assistant Group Integration Documentation"
      - "Home Assistant Services Documentation"
      - "Home Assistant Automation Action Documentation"

  - name: "template_json_parsing_error"
    category: "jinja_template"
    description: "Template errors when from_json filter fails and template tries to call methods on strings"
    error_format: "UndefinedError: 'str object' has no attribute 'get'"
    symptoms:
      - "Template sensors showing 'unavailable' state with JSON parsing errors"
      - "Error messages about string objects not having dictionary methods"
      - "Template rendering failures in sensors or automations"
      - "Intermittent template errors when JSON data is malformed"
    root_causes:
      - "Using from_json filter without checking if parsing succeeded"
      - "Assuming from_json always returns a dictionary/mapping object"
      - "Missing error handling when JSON parsing fails"
      - "Calling dictionary methods (.get(), .keys(), etc.) on string results"
    solution:
      - "Add type checking after from_json: if parsed is mapping"
      - "Use defensive programming with fallback values"
      - "Check if parsed result is actually a dictionary before using dictionary methods"
      - "Provide default empty dictionary when JSON parsing fails"
    examples:
      bad: |
        {% set raw = state_attr('sensor.data','payload') %}
        {% set cfg = (raw | from_json).get('key', {}) if raw else {} %}
        {{ cfg.get('value', 'default') }}
      good: |
        {% set raw = state_attr('sensor.data','payload') %}
        {% set parsed = raw | from_json if raw else {} %}
        {% set cfg = parsed.get('key', {}) if parsed is mapping else {} %}
        {{ cfg.get('value', 'default') }}
    resolution_steps:
      - "Identify the failing template from Home Assistant error messages"
      - "Locate templates using from_json filter without type checking"
      - "Add 'if parsed is mapping' checks before calling dictionary methods"
      - "Provide fallback empty dictionary when JSON parsing fails"
      - "Test template rendering with both valid and invalid JSON inputs"
    prevention_strategies:
      - "Always check if from_json result is a mapping before using dictionary methods"
      - "Use defensive programming patterns in templates with external data"
      - "Test templates with edge cases like malformed JSON or empty values"
      - "Document expected JSON structure for template sensors"
    defensive_patterns:
      json_parsing: "{% set parsed = raw | from_json if raw else {} %}"
      type_checking: "{% set data = parsed.get('key', {}) if parsed is mapping else {} %}"
      fallback_values: "{{ data.get('field', 'default_value') }}"
    tooling:
      detector: "Look for error patterns: 'str object' has no attribute 'get' in template errors"
      validator: "Test templates in Developer Tools > Templates with various JSON inputs"
      json_validator: "Use jq or python -c 'import json; json.loads(data)' to validate JSON"
    references:
      - "Home Assistant Template Documentation"
      - "Jinja2 Template Documentation"
      - "Home Assistant Template Sensor Configuration"
      - "ADR-0020: Template Error Patterns"

  - name: "appdaemon_config_validation_error"
    category: "appdaemon_configuration"
    description: "AppDaemon configuration validation errors due to incorrect data types in YAML configuration"
    error_format: "1 validation error for MainConfig\n[section]\n  Input should be a valid dictionary [type=dict_type, input_value=[value], input_type=[type]]"
    symptoms:
      - "AppDaemon add-on fails to start with configuration validation errors"
      - "Pydantic validation error messages in AppDaemon startup logs"
      - "Add-on exits with code 1 immediately after configuration loading"
      - "Error messages about dictionary type requirements"
    root_causes:
      - "Using boolean values (true/false) for configuration sections that require dictionaries"
      - "Incorrect YAML syntax for dictionary sections like 'api:', 'admin:', 'hadashboard:'"
      - "Mixed data types in configuration sections that expect consistent formatting"
      - "Copy-paste errors from different AppDaemon configuration examples"
    solution:
      - "Convert boolean sections to proper dictionary format: 'api: true' → 'api:'"
      - "Use empty dictionary syntax for sections without specific configuration"
      - "Ensure all top-level configuration sections use consistent YAML formatting"
      - "Validate YAML syntax before deploying AppDaemon configuration"
    examples:
      bad: |
        # AppDaemon configuration with type validation errors
        appdaemon:
          # ... other config
        http:
          url: http://0.0.0.0:5050
        admin:
        api: true  # Boolean not allowed - should be dictionary
        hadashboard:
      good: |
        # AppDaemon configuration with correct types
        appdaemon:
          # ... other config
        http:
          url: http://0.0.0.0:5050
        admin:
        api:  # Empty dictionary format
        hadashboard:
    resolution_steps:
      - "Identify the problematic configuration section from Pydantic error message"
      - "Check AppDaemon documentation for correct configuration format"
      - "Convert boolean or incorrect values to proper dictionary format"
      - "Use 'section:' format for empty dictionary sections"
      - "Restart AppDaemon add-on to validate configuration fixes"
      - "Monitor startup logs for successful configuration loading"
    prevention_strategies:
      - "Always use official AppDaemon configuration documentation as reference"
      - "Test configuration changes in development environment first"
      - "Use YAML linters to validate syntax before deployment"
      - "Keep configuration sections consistent with expected data types"
    tooling:
      detector: "Look for 'validation error for MainConfig' + 'Input should be a valid dictionary'"
      validator: "AppDaemon add-on startup logs show configuration validation results"
      config_test: "Restart AppDaemon add-on to test configuration changes"
    references:
      - "AppDaemon Configuration Documentation"
      - "Pydantic Data Validation Documentation"
      - "Home Assistant AppDaemon Add-on Documentation"

  - name: "appdaemon_file_access_container_path_error"
    category: "appdaemon_file_access"
    description: "AppDaemon apps failing to access files due to container path limitations and incorrect file locations"
    error_format: "FileNotFoundError: [Errno 2] No such file or directory: '/config/[path]/[filename]'"
    symptoms:
      - "App initialization failures with file not found errors"
      - "AppDaemon apps unable to access configuration or data files"
      - "Path resolution errors when apps try to load external files"
      - "Apps failing to start due to missing canonical mapping or configuration files"
    root_causes:
      - "AppDaemon container has limited access to /config subdirectories"
      - "Files placed in /config/domain/ or other paths not accessible from container"
      - "Incorrect path assumptions about container vs host filesystem mapping"
      - "Data files placed in locations not mounted into AppDaemon container"
    solution:
      - "Copy required files to AppDaemon-accessible locations: /config/apps/ or /config/www/"
      - "Update app configuration to use container-accessible paths"
      - "Use /config/www/ for data files to prevent parsing conflicts"
      - "Verify file permissions and accessibility from container perspective"
    examples:
      bad: |
        # apps.yaml referencing inaccessible path
        room_db_updater:
          module: room_db_updater
          class: RoomDbUpdater
          canonical_mapping_file: /config/domain/architecture/area_mapping.yaml  # Deprecated - use /addon_configs/www/area_mapping.yaml
      good: |
        # apps.yaml with container-accessible path
        room_db_updater:
          module: room_db_updater
          class: RoomDbUpdater
          canonical_mapping_file: /addon_configs/www/area_mapping.yaml  # Correct addon_configs path
    resolution_steps:
      - "Identify the missing file path from AppDaemon error logs"
      - "Check if file exists on host filesystem in expected location"
      - "Copy file to AppDaemon-accessible location (/config/www/ or /config/apps/)"
      - "Update app configuration to reference new accessible path"
      - "Restart AppDaemon to test file access from container"
      - "Verify app initialization succeeds with accessible file path"
    container_path_mapping:
      host_addon_configs: "/Volumes/addon_configs/a0d7b954_appdaemon/"
      container_config: "/config/"
      accessible_paths:
        - "/config/apps/ (app modules and configuration)"
        - "/config/www/ (static data files)"
        - "/config/compiled/ (compiled app cache)"
      inaccessible_paths:
        - "/config/domain/ (host-only directories)"
        - "/config/hestia/ (host workspace directories)"
        - "/config/custom_components/ (HA-specific directories)"
    prevention_strategies:
      - "Test file accessibility from AppDaemon container during development"
      - "Use /config/www/ for data files that apps need to read"
      - "Keep app-specific files within AppDaemon add-on directory structure"
      - "Document container path limitations for future app development"
    tooling:
      detector: "Look for 'FileNotFoundError' in AppDaemon app initialization logs"
      path_test: "Test file access: docker exec -it addon_a0d7b954_appdaemon ls /config/[path]"
      validator: "Check AppDaemon app startup logs for successful file loading"
    references:
      - "Home Assistant AppDaemon Add-on Documentation"
      - "Docker Container File System Documentation"
      - "AppDaemon App Development Guide"

  - name: "input_text_yaml_max_limit_exceeded"
    category: "helper_configuration"
    description: "YAML-defined input_text helpers failing validation due to exceeding 255 character limit"
    error_format: "value must be at most 255 for dictionary value 'input_text->[helper_name]->max', got [value]"
    symptoms:
      - "Configuration validation errors for input_text helpers with large max values"
      - "Helpers defined in YAML with max > 255 characters failing to load"
      - "JSON storage requirements exceeding YAML input_text limits"
    root_causes:
      - "Home Assistant YAML input_text helpers limited to 255 characters maximum"
      - "Large JSON storage needs (TTS registries, Plex indexes) requiring >255 chars"
      - "Using YAML configuration instead of UI creation for large storage helpers"
    solution:
      - "Remove large storage helpers from YAML configuration files"
      - "Create helpers via UI (Settings > Devices & Services > Helpers) for large storage"
      - "UI-created helpers support up to 100,000 characters vs YAML's 255 limit"
    examples:
      bad: |
        # domain/helpers/input_text.yaml
        input_text:
          large_json_storage:
            name: "Large JSON Storage"
            max: 4096  # Exceeds 255 limit
            initial: "{}"
      good: |
        # Remove from YAML, create via UI instead
        # Note: large_json_storage created via Settings > Helpers
        # UI creation allows max: 4096+ characters
    resolution_steps:
      - "Remove helper definitions from YAML files in domain/helpers/"
      - "Add helpers via UI: Settings > Devices & Services > Helpers > Add Helper"
      - "Set appropriate max values (up to 100,000) in UI creation dialog"
      - "Verify helpers appear in .storage/input_text after creation"
    prevention_strategies:
      - "Use UI creation for any input_text helper needing >255 characters"
      - "Document large storage helpers as UI-only in configuration comments"
      - "Check .storage/input_text to verify UI-created helper configuration"
    tooling:
      detector: "grep 'value must be at most 255.*input_text' home-assistant.log"
      validator: "/config/bin/config-health /config - validate configuration after changes"
      storage_check: "grep -E 'helper_name' /config/.storage/input_text - verify UI creation"
    references:
      - "Home Assistant Input Text Helper Documentation"
      - "UI Helper Creation vs YAML Configuration Limits"

  - name: "appdaemon_yaml_parsed_as_app_config"
    category: "appdaemon_file_parsing"
    description: "AppDaemon incorrectly parsing data files as app configurations causing startup errors"
    error_format: "BadAppConfigFile: /config/apps/[filename].yaml\nBadAppConfig: The key/value pair of [data] is not valid"
    symptoms:
      - "AppDaemon startup errors about invalid app configuration files"
      - "Data files in /config/apps/ being parsed as app configurations"
      - "BadAppConfig errors for YAML files containing data rather than app definitions"
      - "AppDaemon attempting to load non-app YAML files as applications"
    root_causes:
      - "Placing data files (area_mapping.yaml, configuration files) in /config/apps/ directory"
      - "AppDaemon automatically parsing all YAML files in apps/ directory as app configurations"
      - "Data file structure not matching expected app configuration schema"
      - "Incorrect file organization mixing app definitions with data files"
    solution:
      - "Move data files from /config/apps/ to /config/www/ directory"
      - "Keep only app module files (.py) and apps.yaml in /config/apps/ directory"
      - "Update app configuration references to point to new data file locations"
      - "Use /config/www/ for static data files that apps need to access"
    examples:
      bad: |
        # File organization causing parsing conflicts
        /config/apps/
        ├── apps.yaml              # App configuration (correct)
        ├── room_db_updater.py     # App module (correct)
        └── area_mapping.yaml      # Data file (WRONG - parsed as app config)
      good: |
        # Proper file organization
        /config/apps/
        ├── apps.yaml              # App configuration
        └── room_db_updater.py     # App module
        /config/www/
        └── area_mapping.yaml      # Data file (correct location)
    resolution_steps:
      - "Identify data files incorrectly placed in /config/apps/ from error messages"
      - "Move data files from apps/ directory to www/ directory"
      - "Update app configuration (apps.yaml) to reference new file paths"
      - "Ensure only app modules (.py) and apps.yaml remain in apps/ directory"
      - "Restart AppDaemon to verify clean startup without parsing errors"
      - "Test app functionality with data files in new locations"
    file_organization_best_practices:
      apps_directory:
        purpose: "App modules and configuration only"
        allowed_files: ["apps.yaml", "*.py"]
        prohibited_files: ["data files", "configuration files", "mapping files"]
      www_directory:
        purpose: "Static data files and resources"
        allowed_files: ["*.yaml (data)", "*.json (data)", "*.txt (data)"]
        access_pattern: "Read-only access from apps"
    prevention_strategies:
      - "Maintain clear separation between app code and data files"
      - "Use www/ directory for all static data files accessed by apps"
      - "Review file organization when adding new data files"
      - "Document file placement guidelines for AppDaemon app development"
    tooling:
      detector: "Look for 'BadAppConfigFile' + 'BadAppConfig' in AppDaemon startup logs"
      file_check: "List files in apps directory: ls -la /Volumes/addon_configs/*/apps/"
      validator: "Monitor AppDaemon startup for clean configuration loading"
    references:
      - "AppDaemon App Development Documentation"
      - "AppDaemon File Organization Best Practices"
      - "Home Assistant AppDaemon Add-on File Structure Guide"

  # --- BEGIN: Hestia error pattern — LocalTuya fused-line SyntaxError ---
  - id: localtuya_humidifier_fused_line_syntaxerror
    title: "LocalTuya: humidifier import fails with SyntaxError (fused statements)"
    sources:
      includes:
        - "homeassistant.loader"
        - "homeassistant.config_entries"
    level: error
    match:
      any:
        - regex: "Unexpected exception importing platform custom_components\\.localtuya\\.humidifier"
        - regex: "SyntaxError: invalid syntax"
        - regex: "/custom_components/localtuya/humidifier\\.py"
    classify: integration_patch_required
    cause: |
      Multi-line replacement collapsed two Python statements into one line:
      `modes = {}        self._available_modes = DictSelector(modes)` causing SyntaxError at import.
    fix:
      steps:
        - "Split fused line; ensure newline at EOF."
        - "Normalize modes (list/dict/else) then assign: `self._available_modes = DictSelector(modes)` at the outer indent."
        - "Compile-check: `python3 -m py_compile custom_components/localtuya/humidifier.py`."
        - "Restart Home Assistant."
    verify:
      - "No SyntaxError in logs for localtuya.humidifier"
      - "Component loads; entity state available"
    suppress:
      when:
        - "file: custom_components/localtuya/humidifier.py"
        - "grep contains: '^\\s*self\\._available_modes = DictSelector\\(modes\\)$'"
  # --- END: Hestia error pattern — LocalTuya fused-line SyntaxError ---

  # --- BEGIN: Hestia error pattern — LocalTuya blocking import (warning) ---
  - id: localtuya_blocking_import_warning
    title: "LocalTuya: blocking import detected in event loop"
    sources:
      includes:
        - "homeassistant.util.loop"
    level: warning
    match:
      all:
        - regex: "Detected blocking call to import_module"
        - regex: "custom_components\\.localtuya"
    classify: upstream_warning
    cause: |
      LocalTuya forwards platform setups triggering a synchronous import inside the event loop.
      This is noisy but not setup-fatal.
    fix:
      steps:
        - "Monitor occurrence count after updates."
        - "If frequency >3 per startup, file upstream issue with integration version & HA core version."
    verify:
      - "Integration still sets up successfully."
    suppress:
      policy:
        - "treat as informational unless coupled with import failure"
  # --- END: Hestia error pattern — LocalTuya blocking import (warning) ---

  # --- BEGIN: Hestia advisory pattern — Copilot outside-workspace/sensitive-file gate ---
  - id: copilot_outside_workspace_sensitive_gate
    title: "Copilot: edit blocked by outside-workspace or sensitive-file gate"
    sources:
      includes:
        - "copilot"
        - "vscode"
        - "workspace"
    level: info
    match:
      any:
        - regex: "Allow edits to sensitive files\\?"
        - regex: "outside of your workspace"
    classify: workspace_root_mismatch
    cause: |
      Edits were issued from a virtual chat buffer or non-primary root; Copilot's approval gate triggers.
    fix:
      steps:
        - "Anchor edit to a real file under /config (open editor + Copilot: Edit)."
        - "Keep /config as single-root workspace; avoid virtual `vscode-chat-code-block://` anchors."
        - "Optionally scope `chat.tools.edits.autoApprove` in .vscode to known-safe paths."
    verify:
      - "Subsequent edits to files in /config proceed without the outside-workspace prompt (except truly sensitive cases)."
  # --- END: Hestia advisory pattern — Copilot outside-workspace/sensitive-file gate ---

  # --- BEGIN: Hestia error pattern — Template missing closing brace ---
  - id: template_missing_closing_brace
    title: "Template: missing closing brace breaks template rendering"
    category: "jinja_template"
    description: "Template syntax errors due to missing closing braces in Jinja expressions"
    error_format: "TemplateSyntaxError: unexpected end of template, expected '}'"
    symptoms:
      - "Template rendering failures in Home Assistant"
      - "Automation execution errors with template conditions/variables"
      - "Sensor template evaluation failures"
      - "Purple syntax highlighting in editors for content after the error"
    root_causes:
      - "Missing closing brace }} in Jinja template expressions"
      - "Incomplete template expressions during copy/paste operations"
      - "Syntax errors introduced during template editing"
    solution:
      - "Add missing closing braces to complete template expressions"
      - "Validate template syntax before deployment"
      - "Use template testing tools to verify expression completeness"
    examples:
      bad: |
        room_config: >-
          {% if cfg is string %}
            {{ cfg | from_json %}  # Missing closing brace
          {% endif %}
      good: |
        room_config: >-
          {% if cfg is string %}
            {{ cfg | from_json }}  # Properly closed
          {% endif %}
    resolution_steps:
      - "Identify template syntax errors from Home Assistant logs"
      - "Check for missing closing braces in template expressions"
      - "Test template syntax using Developer Tools > Template"
      - "Validate YAML configuration after template fixes"
    prevention_strategies:
      - "Use editor syntax highlighting to catch template errors"
      - "Test templates in Developer Tools before deployment"
      - "Use template validation in CI/CD pipelines"
    tooling:
      detector: "grep -r '{{.*[^}]$' **/*.yaml - find incomplete template expressions"
      validator: "Home Assistant Developer Tools > Template - test template syntax"
    references:
      - "Home Assistant Template Documentation"
      - "Jinja2 Template Syntax Reference"
      - "ADR-0020: Template Error Patterns"
  # --- END: Hestia error pattern — Template missing closing brace ---