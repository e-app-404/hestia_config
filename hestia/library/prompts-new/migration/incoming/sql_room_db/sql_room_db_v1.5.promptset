# SQL Room Database Architecture — Promptset v1.5 (Incremental Delivery, Strategos)

> Purpose: eliminate long-run timeouts by **staggering** work into micro-phases with strict per-turn output ceilings and operator gates. This preserves all safety/ADR constraints from v1.4 while ensuring each response is lightweight and deterministic.

```yaml
promptset:
  id: sql-room-database-architecture.promptset
  version: 1.5
  created: "2025-10-08"
  description: >
    Incremental, operator-gated execution plan to replace HACS Variable with a SQL-backed
    room database for Adaptive Motion Lighting + Valetudo Vacuum Control. Uses micro-phases,
    strict output ceilings, and file-by-file generation to avoid timeouts.

  persona: strategos_gpt
  legacy_compatibility: false
  schema_version: 1.0

  # ---------------- Runtime Delivery Controls ----------------
  delivery:
    mode: incremental
    microphase_size:
      max_files_per_turn: 2            # never emit more than 2 complete files per response
      max_code_blocks_per_turn: 3      # hard cap on code blocks
      max_code_block_bytes: 20000      # per code block (≈20 KB)
      max_text_tokens: 900             # keep prose tight
    gating:
      require_operator_ack: true       # stop after each micro-phase; present NEXT_ACTION_OPTIONS
      tokens_dir: "/config/.sql_room_db_tokens"
      proceed_signal: "NEXT"           # operator replies with NEXT or a specific command
    failure_handling:
      on_tool_error: "downgrade_output" # emit skeletal manifest instead of full files
      avoid_background_work: true       # do not queue future work; each turn is complete
    verbosity:
      analysis_detail: "brief"
      code_comments: "essential_only"

  # ---------------- Safety & Governance (inherits v1.4) ----------------
  globals:
    timezone: "Europe/London"
    ha_state_char_limit: 255
    naming:
      sql_sensors:
        motion: "sensor.room_configs_motion_lighting"
        vacuum: "sensor.room_configs_vacuum_control"
        cleaning_need: "sensor.rooms_needing_cleaning"
    recorder_db_default: false
    scan_interval_seconds: 30
    json1_required_functions: ["json_extract","json_group_object","json_group_array","json_valid"]
    room_id_pattern: "^[a-z0-9_]+$"
    canonical_mapping_file: "/config/architecture/area_mapping.yaml"
    schema_expected: 1
    appdaemon_base_url: "http://appdaemon:5050"
    valetudo_base_topic_var: "valetudo_base_topic"
    write_rate_limit_seconds: 2
    max_config_size_bytes: 4096
    allowed_domains: ["motion_lighting","vacuum_control","shared"]

  hard_guardrails:
    - "Two-column SELECT only: 'state'|'count' + 'payload'."
    - "JSON never in sensor state; always in attribute payload."
    - "Numeric_state never templated; use template condition."
    - "Platform-level scan_interval: {{ scan_interval_seconds }}."
    - "Transactional writes (BEGIN IMMEDIATE … COMMIT) with schema_version guard == {{ schema_expected }}."
    - "room_id matches {{ room_id_pattern }} and exists in {{ canonical_mapping_file }} before writes."
    - "Recorder excludes for sensor.room_configs_* and sensor.rooms_needing_cleaning."
    - "If JSON1 missing → generate normalized fallback schema + alternate sensors."
    - "No background/async promises; each turn must be self-contained."

  # ---------------- Operator Commands ----------------
  operator_commands:
    - id: NEXT
      description: "Proceed to the next micro-phase with default path."
    - id: GENERATE
      params: [component_path]
      description: "Generate a specific file/component now (e.g., GENERATE /config/packages/room_database/sql_sensors.yaml)."
    - id: PATCH
      params: [component_path, diff]
      description: "Apply a focused amendment to an already emitted file."
    - id: SKIP
      params: [phase_or_file]
      description: "Skip a micro-phase/file and continue."

  # ---------------- Micro-Phases (staggered) ----------------
  micro_phases:
    - id: P0.preflight
      label: "Preflight & Plan"
      deliver:
        - manifest.min:                     # ≤ 15 lines
            - target_paths
            - risk_flags
            - NEXT_ACTION_OPTIONS
      stop_after: true

    - id: P1.research
      label: "Research (thin)"
      deliver:
        - research_foundation.min:          # compressed bullet lists only
            keys: [sql_capabilities, sqlite_patterns, consolidation_opportunities]
        - NEXT_ACTION_OPTIONS
      stop_after: true

    - id: P2.deconstruction
      label: "Deconstruction (tables only)"
      deliver:
        - deconstruction_tables:            # compact YAML tables; no prose
        - NEXT_ACTION_OPTIONS
      stop_after: true

    - id: P3.architecture
      label: "Architecture (schema-first)"
      deliver:
        - database_init.sql                 # file 1 (full)
        - sql_sensors.yaml.skeleton         # file 2 (skeleton with stubs)
        - NEXT_ACTION_OPTIONS
      stop_after: true

    - id: P4.impl.room_db
      label: "Implementation A — Room DB core"
      deliver:
        - sql_sensors.yaml (final)          # replaces skeleton
        - shell_commands.yaml OR appdaemon app.yaml+py (choose path)
        - NEXT_ACTION_OPTIONS
      stop_after: true

    - id: P4b.impl.motion
      label: "Implementation B — Motion lighting"
      deliver:
        - motion_lighting_v2/automations.yaml (room=bedroom only)
        - templates.yaml (1 compatibility sensor)
        - NEXT_ACTION_OPTIONS
      stop_after: true

    - id: P4c.impl.vacuum
      label: "Implementation C — Vacuum control"
      deliver:
        - vacuum_control_v2/scripts.yaml (single script)
        - mqtt_commands.yaml (base topic input_text)
        - NEXT_ACTION_OPTIONS
      stop_after: true

    - id: P5.validation
      label: "Validation pack (thin)"
      deliver:
        - acceptance_criteria.yaml (checkbox list)
        - diagnostics.jinja (short)
        - recorder_policy.yaml
        - NEXT_ACTION_OPTIONS
      stop_after: true

  # ---------------- Phase Prompts (compact) ----------------
  prompts:
    - id: P0.preflight
      prompt: |
        Output `manifest.min` with:
        - target_paths (list of files you plan to emit across phases)
        - risk_flags (top 5 w/ one-line mitigations)
        - NEXT_ACTION_OPTIONS: [NEXT, GENERATE <path>, SKIP <phase>]
        Keep under 15 lines. CONFIDENCE: [n]%

    - id: P1.research
      prompt: |
        Output `research_foundation.min`:
        sql_capabilities: 5 bullets max
        sqlite_patterns: 5 bullets max
        consolidation_opportunities: 5 bullets max
        Then `NEXT_ACTION_OPTIONS`. CONFIDENCE: [n]%

    - id: P2.deconstruction
      prompt: |
        Emit YAML tables only (no prose):
        deconstruction_tables:
          motion_entities: {}
          vacuum_entities: {}
          template_sensors: []
        Then `NEXT_ACTION_OPTIONS`. CONFIDENCE: [n]%

    - id: P3.architecture
      prompt: |
        Emit two files max:
        - database_init.sql (complete, WAL, schema_version={{schema_expected}})
        - sql_sensors.yaml.skeleton (single platform, three queries with placeholders)
        Then `NEXT_ACTION_OPTIONS`. CONFIDENCE: [n]%

    - id: P4.impl.room_db
      prompt: |
        Choose write path (shell OR AppDaemon) based on sqlite3 availability token. Emit at most two files:
        - sql_sensors.yaml (final, two-column SELECT + platform scan_interval)
        - chosen write path file(s)
        Then `NEXT_ACTION_OPTIONS`. CONFIDENCE: [n]%

    - id: P4b.impl.motion
      prompt: |
        Emit at most two files:
        - motion_lighting_v2/automations.yaml (bedroom only, template conditions)
        - templates.yaml (one compatibility sensor)
        Then `NEXT_ACTION_OPTIONS`. CONFIDENCE: [n]%

    - id: P4c.impl.vacuum
      prompt: |
        Emit at most two files:
        - vacuum_control_v2/scripts.yaml (single script, tojson payload)
        - mqtt_commands.yaml (input_text base topic)
        Then `NEXT_ACTION_OPTIONS`. CONFIDENCE: [n]%

    - id: P5.validation
      prompt: |
        Emit at most two files:
        - acceptance_criteria.yaml (checkboxes only)
        - diagnostics.jinja (short health checks)
        Also emit recorder_policy.yaml if not yet emitted.
        Then STOP. CONFIDENCE: [n]%

  # ---------------- Self-Checks (per turn) ----------------
  self_checks:
    - "Respect microphase_size caps: <=2 files, <=3 code blocks, <=20KB per block."
    - "No JSON in sensor state; payload attribute only."
    - "Numeric_state thresholds not templated."
    - "Transactional writes + schema guard present when write files are emitted."
    - "Names match globals.naming.*; scan_interval present in sql_sensors.yaml."
    - "No background promises; include NEXT_ACTION_OPTIONS at end of each turn."
```
