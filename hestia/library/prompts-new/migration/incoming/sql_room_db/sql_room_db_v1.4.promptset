# SQL Room Database Architecture — Promptset v1.4 (Final‑Locked, Strategos)

> **This is the final, operator‑proof promptset**. It closes all residual risks: state/attribute safety, JSON1 preflight tokens, transactional writes with schema/version guards, canonical room mapping validation, deterministic naming, recorder hygiene, no runtime `!secret` usage in templates, no unsupported Jinja helpers, robust routing between AppDaemon and shell fallback, and visible health sensors. Use as the single source of truth for Strategos GPT executions.

````yaml
promptset:
  id: sql-room-database-architecture.promptset
  version: 1.4
  created: "2025-10-08"
  description: >
    Production-grade, five-phase plan to replace HACS Variable with a SQL-backed room database
    for Adaptive Motion Lighting + Valetudo Vacuum Control. Guarantees HA state safety,
    transactional updates, JSON1 portability, ADR compliance, and deterministic deliverables.

  persona: strategos_gpt
  legacy_compatibility: false
  schema_version: 1.0

  execution_context:
    model: "GPT-5 Extended Thinking"
    mandate: "Replace 70+ helper entities with <10 SQL-backed access points"
    success_criteria:
      - "Copy-paste deployable packages; `homeassistant.check_config` passes"
      - "≥70% entity reduction; identical behavior preserved"
      - "SQL query p50 < 100ms; update p50 < 200ms"
      - "ADR-0008 / ADR-0021 / ADR-0024 compliant"

  globals:
    timezone: "Europe/London"
    ha_state_char_limit: 255
    naming:
      sql_sensors:
        motion: "sensor.room_configs_motion_lighting"      # plural 'room_configs'
        vacuum: "sensor.room_configs_vacuum_control"
        cleaning_need: "sensor.rooms_needing_cleaning"
    recorder_db_default: false                      # use /config/room_database.db by default
    scan_interval_seconds: 30                       # platform-level cadence for SQL platform
    json1_required_functions: ["json_extract", "json_group_object", "json_group_array", "json_valid"]
    room_id_pattern: "^[a-z0-9_]+$"                 # slugified room IDs
    canonical_mapping_file: "/config/architecture/area_mapping.yaml"
    tokens_dir: "/config/.sql_room_db_tokens"      # preflight/migration tokens directory
    schema_expected: 1                               # expected DB schema_version
    appdaemon_base_url: "http://appdaemon:5050"     # override if different
    valetudo_base_topic_var: "valetudo_base_topic"   # single runtime source (input_text)
    dry_run: false                                   # if true, AppDaemon logs but does not mutate
    write_rate_limit_seconds: 2                      # min seconds between writes per room/domain
    max_config_size_bytes: 4096                      # sanity cap per JSON payload
    allowed_domains: ["motion_lighting", "vacuum_control", "shared"]

  artifacts:
    required:
      - { description: "Adaptive motion lighting package", path: /mnt/data/adaptive_motion_lighting/ }
      - { description: "Valetudo vacuum control package", path: /mnt/data/valetudo/ }
      - { description: "HA SQL integration guide", path: /mnt/data/homeassistant_sql_integration_guide.md }
      - { description: "SQLite usage & performance", path: /mnt/data/sqlite_homeassistant_patterns.md }
      - { description: "Normalization & determinism rules", path: /mnt/data/ADR/ADR-0008-normalization-and-determinism-rules.md }
      - { description: "Motion/occupancy/presence governance", path: /mnt/data/ADR/ADR-0021-motion-occupancy-presence-signals.md }
      - { description: "Canonical path requirements", path: /mnt/data/ADR/ADR-0024-canonical-config-path.md }
      - { description: "Canonical mappings", path: /mnt/data/architecture/{area_mapping.yaml,presence_mapping.yaml,tier_mapping.yaml} }

  bindings:
    protocols:
      - sql_database_first_architecture
      - room_scoped_data_modeling
      - entity_reduction_optimization
      - production_grade_validation
      - adr_compliance_enforcement

    hard_guardrails:
      # HA / SQL Sensor safety
      - "Two-column SELECT only: first short column named 'state' (or 'count'), second column named 'payload' (JSON)."
      - "The SQL sensor 'column:' MUST select 'state' or 'count'. Extra column becomes attribute automatically."
      - "Never place JSON in sensor state; only read via state_attr('…','payload') | from_json."
      - "No templated thresholds for numeric_state; use template conditions."
      - "Platform-level scan_interval MUST be {{ scan_interval_seconds }} for the SQL platform."
      - "All sensor entity_ids MUST match globals.naming.sql_sensors.* exactly."

      # DB / write safety
      - "Default DB is /config/room_database.db (not recorder)."
      - "All writes MUST be transactional (BEGIN IMMEDIATE … COMMIT)."
      - "Preferred write path: AppDaemon service with validation, schema guard, logging, and rate limiting."
      - "Shell fallback MUST use /bin/sh heredoc, verify sqlite3 presence, and enforce schema version guard."
      - "room_id MUST match {{ room_id_pattern }} and MUST exist in {{ canonical_mapping_file }} before any write."
      - "domain MUST be in {{ allowed_domains }}; otherwise abort."
      - "Reject writes if config JSON > {{ max_config_size_bytes }} bytes or if dry_run is true."

      # Environment & portability
      - "Before creating sensors, run JSON1 preflight (NOT a sensor). If missing → normalized fallback schema + alternate sensors."
      - "If sqlite3 binary is missing → disable shell fallback; emit AppDaemon path + HA rest_command to call it."

      # Recorder, secrets, unsupported constructs
      - "Add recorder excludes for bulk JSON sensors to avoid DB bloat."
      - "Do NOT reference !secret at runtime in templates; use input_text.{{ valetudo_base_topic_var }} as the single base-topic source."
      - "Do NOT use unsupported Jinja helpers (e.g., path_exists). Use command_line sensors for file/token checks."

  response_contracts:
    research_foundation_shape:
      keys: [sql_capabilities, sqlite_patterns, current_architecture, consolidation_opportunities, governance_constraints]
    deconstruction_shape:
      keys: [adaptive_lighting_core, valetudo_core, consolidation_targets, gui_compatibility_matrix]
    architecture_shape:
      keys: [database_schema, sql_sensors, update_mechanisms, template_functions, package_structure, integration_strategy, migration_strategy]
    implementation_outputs:
      files:
        - "/config/packages/room_database/sql_sensors.yaml"
        - "/config/packages/room_database/shell_commands.yaml"          # shell fallback (auto-disabled if no sqlite3)
        - "/config/packages/room_database/database_init.sql"
        - "/config/packages/room_database/preflight.yaml"              # preflights, token creation, health sensors, check_config
        - "/config/packages/room_database/recorder_policy.yaml"
        - "/config/packages/room_database/rest_command.yaml"           # AppDaemon endpoint wiring
        - "/config/packages/motion_lighting_v2/automations.yaml"
        - "/config/packages/motion_lighting_v2/templates.yaml"
        - "/config/packages/vacuum_control_v2/scripts.yaml"
        - "/config/packages/vacuum_control_v2/mqtt_commands.yaml"
        - "/config/appdaemon/apps/room_db_updater/app.yaml"
        - "/config/appdaemon/apps/room_db_updater/room_db_updater.py"
        - "/config/.sql_room_db_tokens/README.txt"
        - "/config/secrets.example.yaml"
    validation_shape:
      keys: [acceptance_criteria, diagnostics_templates, migration_tokens, rollback_procedures, performance_benchmarks]

  non_negotiables:
    - "Exactly three SQL queries (motion, vacuum, cleaning_need) in one platform block; states are 'ok' or integer count."
    - "All access uses state_attr('…','payload') | from_json."
    - "Presence modulates timeouts (ADR-0021), never blocks activation."
    - "Writes are transactional, schema-guarded, rate-limited; failures notify and do not mutate."
    - "Recorder excludes for sensor.room_configs_* and sensor.rooms_needing_cleaning are present."

  prompts:

    # PHASE 1 — Research
    - id: sql_room_db.research.foundation
      persona: strategos_gpt
      label: "Research — SQL Patterns & Package Inventory"
      mode: research_mode
      protocols: [sql_database_first_architecture, production_grade_validation]
      bindings:
        - /mnt/data/homeassistant_sql_integration_guide.md
        - /mnt/data/sqlite_homeassistant_patterns.md
        - /mnt/data/adaptive_motion_lighting/
        - /mnt/data/valetudo/
        - /mnt/data/ADR/ADR-0008-normalization-and-determinism-rules.md
      prompt: |
        Produce `research_foundation` per response_contracts.research_foundation_shape.
        Include SELECT-only constraints, JSON1 functions, recorder-vs-dedicated DB tradeoffs, and clear Variable→SQL consolidation targets.
        CONFIDENCE: [n]%

    # PHASE 2 — Deconstruction
    - id: sql_room_db.deconstruction.objectives
      persona: strategos_gpt
      label: "Deconstruction — Feature Extraction & Mapping"
      mode: deconstruction_mode
      protocols: [room_scoped_data_modeling, entity_reduction_optimization]
      bindings:
        - /mnt/data/adaptive_motion_lighting/
        - /mnt/data/valetudo/
        - /mnt/data/ADR/ADR-0021-motion-occupancy-presence-signals.md
        - /mnt/data/architecture/area_mapping.yaml
      prompt: |
        Produce `deconstruction_analysis` per response_contracts.deconstruction_shape.
        List per-room timeouts, bypasses, illuminance thresholds (if discoverable), and Valetudo topics/payload shapes.
        Flag GUI dependencies needing attribute payloads (no JSON in state).
        CONFIDENCE: [n]%

    # PHASE 3 — Architecture
    - id: sql_room_db.architecture.scaffold
      persona: strategos_gpt
      label: "Architecture — Unified Schema & Integration"
      mode: architecture_mode
      protocols: [sql_database_first_architecture, room_scoped_data_modeling, adr_compliance_enforcement]
      bindings:
        - /mnt/data/homeassistant_sql_integration_guide.md
        - /mnt/data/sqlite_homeassistant_patterns.md
        - /mnt/data/ADR/ADR-0024-canonical-config-path.md
        - /mnt/data/architecture/tier_mapping.yaml
      prompt: |
        Deliver `architecture_design` per response_contracts.architecture_shape with:
        - DB schema (primary path):
          * `room_configs(room_id, config_domain, config_data TEXT, version INT, created_at, updated_at)`; PK(room_id, config_domain)
          * Index: (config_domain, room_id)
          * PRAGMAs: WAL; synchronous=NORMAL
          * `schema_version(version INT NOT NULL)` with initial value {{ schema_expected }}
        - JSON1 preflight (NOT a sensor):
          * Ensure {{ tokens_dir }} exists; clear previous JSON1 tokens
          * Run: `sqlite3 /config/room_database.db "PRAGMA compile_options;"` and check for 'JSON1' (case-insensitive)
          * If present → touch `{{ tokens_dir }}/MIGRATION_TOKEN_JSON1_OK`
          * If absent → touch `{{ tokens_dir }}/MIGRATION_TOKEN_JSON1_MISSING` and generate normalized fallback schema + alternate sensors
        - Normalized fallback schema (no JSON1):
          * Tables: `motion_lighting_config(room_id TEXT PK, timeout INT, bypass INT, illuminance_threshold INT, last_triggered TEXT, presence_timeout_multiplier REAL)`
          * `vacuum_control_config(room_id TEXT PK, segment_id INT, last_cleaned TEXT, cleaning_frequency INT, needs_cleaning INT)`
          * Fallback sensors: return 'state'="ok" and build a compact pseudo-JSON string via `room_id||':'||timeout` concatenation into 'payload'; templates must parse this simple map if JSON1 missing.
        - SQL sensors (primary path): one platform, `db_url: sqlite:////config/room_database.db`, `scan_interval: {{ scan_interval_seconds }}`; three queries with columns `state|count` + `payload`; `column:` selects the short column.
        - Update mechanisms:
          * Preferred: AppDaemon `room_db_updater` — validates room_id via {{ canonical_mapping_file }}, enforces schema_version, dry_run + rate limit, size caps, parameterized queries, logging + persistent notifications on failure.
          * Fallback: /bin/sh heredoc shell_command — verifies sqlite3, enforces schema_version, uses BEGIN IMMEDIATE/COMMIT and `tojson`.
        - Template accessors: ONLY state_attr(...,'payload') | from_json (primary path) or custom parser for fallback map (documented).
        - Recorder policy: exclude `sensor.room_configs_*` and `sensor.rooms_needing_cleaning`.
        - Package structure: under /config/packages per ADR-0024.
        CONFIDENCE: [n]%

    # PHASE 4 — Implementation
    - id: sql_room_db.implementation.packages
      persona: strategos_gpt
      label: "Implementation — Production Packages"
      mode: implementation_mode
      protocols: [production_grade_validation, adr_compliance_enforcement, entity_reduction_optimization]
      bindings:
        - /mnt/data/ADR/ADR-0008-normalization-and-determinism-rules.md
        - /mnt/data/ADR/ADR-0021-motion-occupancy-presence-signals.md
        - /mnt/data/hestia_structure.md
      prompt: |
        Emit the files in response_contracts.implementation_outputs with these rules and examples:

        **/config/packages/room_database/sql_sensors.yaml** (primary path):
        ```yaml
        sensor:
          - platform: sql
            db_url: sqlite:////config/room_database.db
            scan_interval: {{ scan_interval_seconds }}
            queries:
              - name: "Room Configs — Motion Lighting"
                query: >
                  SELECT 'ok' AS state,
                         json_group_object(room_id, config_data) AS payload
                  FROM room_configs
                  WHERE config_domain = 'motion_lighting';
                column: state
              - name: "Room Configs — Vacuum Control"
                query: >
                  SELECT 'ok' AS state,
                         json_group_object(room_id, config_data) AS payload
                  FROM room_configs
                  WHERE config_domain = 'vacuum_control';
                column: state
              - name: "Rooms Needing Cleaning"
                query: >
                  SELECT COALESCE(json_group_array(room_id),'[]') AS payload,
                         json_array_length(COALESCE(json_group_array(room_id),'[]')) AS count
                  FROM room_configs
                  WHERE config_domain = 'vacuum_control'
                    AND json_extract(config_data, '$.needs_cleaning') = 1;
                column: count
        ```

        **/config/packages/room_database/shell_commands.yaml** (fallback only):
        ```yaml
        shell_command:
          update_room_config: >-
            /bin/sh -c 'command -v sqlite3 >/dev/null 2>&1 || exit 123; sqlite3 /config/room_database.db <<"SQL"\nBEGIN IMMEDIATE;\nSELECT CASE WHEN (SELECT version FROM schema_version)={{ schema_expected }} THEN 1 ELSE RAISE(ABORT,"SCHEMA_VERSION_MISMATCH") END;\nINSERT OR REPLACE INTO room_configs (room_id, config_domain, config_data, updated_at)\nVALUES ("{{ room_id }}","{{ domain }}","{{ config_data | tojson }}", datetime("now"));\nCOMMIT;\nSQL'
          update_motion_timeout: >-
            /bin/sh -c 'command -v sqlite3 >/dev/null 2>&1 || exit 123; sqlite3 /config/room_database.db <<"SQL"\nBEGIN IMMEDIATE;\nSELECT CASE WHEN (SELECT version FROM schema_version)={{ schema_expected }} THEN 1 ELSE RAISE(ABORT,"SCHEMA_VERSION_MISMATCH") END;\nUPDATE room_configs\nSET config_data = json_set(config_data, "$.timeout", {{ timeout }}), updated_at = datetime("now")\nWHERE room_id="{{ room_id }}" AND config_domain="motion_lighting";\nCOMMIT;\nSQL'
          mark_room_cleaned: >-
            /bin/sh -c 'command -v sqlite3 >/dev/null 2>&1 || exit 123; sqlite3 /config/room_database.db <<"SQL"\nBEGIN IMMEDIATE;\nSELECT CASE WHEN (SELECT version FROM schema_version)={{ schema_expected }} THEN 1 ELSE RAISE(ABORT,"SCHEMA_VERSION_MISMATCH") END;\nUPDATE room_configs\nSET config_data = json_set(config_data, "$.last_cleaned", datetime("now"), "$.needs_cleaning", 0), updated_at = datetime("now")\nWHERE room_id="{{ room_id }}" AND config_domain="vacuum_control";\nCOMMIT;\nSQL'
        ```

        **/config/packages/room_database/database_init.sql**:
        ```sql
        PRAGMA journal_mode=WAL;\nPRAGMA synchronous=NORMAL;\nCREATE TABLE IF NOT EXISTS room_configs (\n  room_id TEXT NOT NULL,\n  config_domain TEXT NOT NULL,\n  config_data TEXT NOT NULL,\n  version INTEGER DEFAULT 1,\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n  PRIMARY KEY (room_id, config_domain)\n);\nCREATE INDEX IF NOT EXISTS idx_room_configs_domain_room ON room_configs(config_domain, room_id);\nCREATE TABLE IF NOT EXISTS schema_version (version INTEGER NOT NULL);\nINSERT OR IGNORE INTO schema_version(version) VALUES({{ schema_expected }});
        ```

        **/config/packages/room_database/preflight.yaml** (tokens, health sensors, check_config):
        ```yaml
        shell_command:
          room_db_json1_preflight: >-
            /bin/sh -c 'mkdir -p {{ tokens_dir }}; rm -f {{ tokens_dir }}/MIGRATION_TOKEN_JSON1_*; if sqlite3 /config/room_database.db "PRAGMA compile_options;" | grep -i JSON1 >/dev/null; then touch {{ tokens_dir }}/MIGRATION_TOKEN_JSON1_OK; else touch {{ tokens_dir }}/MIGRATION_TOKEN_JSON1_MISSING; fi'
          room_db_sqlite_presence: >-
            /bin/sh -c 'mkdir -p {{ tokens_dir }}; rm -f {{ tokens_dir }}/MIGRATION_TOKEN_SQLITE3_*; if command -v sqlite3 >/dev/null 2>&1; then touch {{ tokens_dir }}/MIGRATION_TOKEN_SQLITE3_OK; else touch {{ tokens_dir }}/MIGRATION_TOKEN_SQLITE3_MISSING; fi'
        command_line:
          - sensor:
              name: "Room DB Token — SQLITE3"
              unique_id: room_db_token_sqlite3
              command: "/bin/sh -c 'test -f {{ tokens_dir }}/MIGRATION_TOKEN_SQLITE3_OK && echo ok || echo missing'"
              scan_interval: 300
          - sensor:
              name: "Room DB Token — JSON1"
              unique_id: room_db_token_json1
              command: "/bin/sh -c 'test -f {{ tokens_dir }}/MIGRATION_TOKEN_JSON1_OK && echo ok || echo missing'"
              scan_interval: 300
        binary_sensor:
          - platform: template
            sensors:
              room_db_sqlite3_ok:
                device_class: connectivity
                value_template: "{{ is_state('sensor.room_db_token_—_sqlite3','ok') }}"
              room_db_json1_ok:
                device_class: connectivity
                value_template: "{{ is_state('sensor.room_db_token_—_json1','ok') }}"
        automation:
          - alias: "Room DB Preflight — On Start"
            id: room_db_preflight_on_start
            trigger:
              - platform: homeassistant
                event: start
            action:
              - service: shell_command.room_db_sqlite_presence
              - service: shell_command.room_db_json1_preflight
              - service: homeassistant.check_config
              - choose:
                  - conditions: "{{ is_state('binary_sensor.room_db_sqlite3_ok', 'off') }}"
                    sequence:
                      - service: persistent_notification.create
                        data:
                          title: "Room DB Preflight"
                          message: "> sqlite3 not found — shell fallback disabled; AppDaemon/Node-RED path required."
                  - conditions: "{{ is_state('binary_sensor.room_db_json1_ok', 'off') }}"
                    sequence:
                      - service: persistent_notification.create
                        data:
                          title: "Room DB Preflight"
                          message: "> SQLite JSON1 missing — using normalized schema + alternate sensors."
        ```

        **/config/packages/room_database/recorder_policy.yaml**:
        ```yaml
        recorder:
          exclude:
            entity_globs:
              - sensor.room_configs_*
              - sensor.rooms_needing_cleaning
        ```

        **/config/packages/room_database/rest_command.yaml** (AppDaemon endpoint wiring):
        ```yaml
        rest_command:
          room_db_update_config:
            url: "{{ appdaemon_base_url }}/api/app/room_db_updater/room_db/update_config"
            method: post
            headers:
              accept: application/json
              content_type: application/json
            payload: >-
              {{ {
                'room_id': room_id,
                'domain': domain,
                'config_data': config_data
              } | tojson }}
        ```

        **/config/appdaemon/apps/room_db_updater/app.yaml**:
        ```yaml
        room_db_updater:
          module: room_db_updater
          class: RoomDbUpdater
          db_path: /config/room_database.db
          schema_expected: {{ schema_expected }}
          canonical_mapping_file: {{ canonical_mapping_file }}
          dry_run: {{ dry_run }}
          write_rate_limit_seconds: {{ write_rate_limit_seconds }}
          max_config_size_bytes: {{ max_config_size_bytes }}
        ```

        **/config/appdaemon/apps/room_db_updater/room_db_updater.py** (preferred path skeleton):
        ```python
        import appdaemon.plugins.hass.hassapi as hass
        import json, sqlite3, yaml, re, time, os

        ROOM_ID_RE = re.compile(r"{{ room_id_pattern }}")

        class RoomDbUpdater(hass.Hass):
            def initialize(self):
                self.db_path = self.args.get("db_path")
                self.schema_expected = int(self.args.get("schema_expected", 1))
                self.map_file = self.args.get("canonical_mapping_file")
                self.dry_run = bool(self.args.get("dry_run", False))
                self.rate = int(self.args.get("write_rate_limit_seconds", 2))
                self.max_size = int(self.args.get("max_config_size_bytes", 4096))
                self.last_write = {}
                self.register_endpoint(self.update_config, "room_db/update_config")
                self.log("RoomDbUpdater initialized")

            def _validate_room(self, room_id):
                if not ROOM_ID_RE.match(room_id or ""):
                    raise ValueError("Invalid room_id slug")
                with open(self.map_file, "r") as f:
                    amap = yaml.safe_load(f) or {}
                if room_id not in (amap.get("rooms") or {}):
                    raise ValueError("room_id not in canonical mapping")

            def _schema_ok(self, cur):
                cur.execute("SELECT version FROM schema_version")
                v = cur.fetchone()[0]
                if int(v) != self.schema_expected:
                    raise RuntimeError("SCHEMA_VERSION_MISMATCH")

            def _ratelimit(self, room_id, domain):
                key = f"{room_id}:{domain}"
                now = time.time()
                if now - self.last_write.get(key, 0) < self.rate:
                    raise RuntimeError("RATE_LIMIT")
                self.last_write[key] = now

            def update_config(self, data):
                try:
                    room_id = data.get("room_id")
                    domain = data.get("domain")
                    cfg = data.get("config_data")
                    if domain not in {{ allowed_domains }}:
                        raise ValueError("INVALID_DOMAIN")
                    self._validate_room(room_id)
                    js = json.dumps(cfg, separators=(",", ":"))
                    if len(js.encode("utf-8")) > self.max_size:
                        raise ValueError("CONFIG_TOO_LARGE")
                    self._ratelimit(room_id, domain)
                    if self.dry_run:
                        self.log(f"DRY_RUN: would update {room_id}/{domain}: {js}")
                        return {"status": "dry_run"}
                    conn = sqlite3.connect(self.db_path)
                    cur = conn.cursor()
                    try:
                        self._schema_ok(cur)
                        conn.execute("BEGIN IMMEDIATE")
                        cur.execute(
                            "INSERT OR REPLACE INTO room_configs (room_id, config_domain, config_data, updated_at) VALUES (?,?,?, datetime('now'))",
                            (room_id, domain, js)
                        )
                        conn.commit()
                    except Exception:
                        conn.rollback()
                        raise
                    finally:
                        conn.close()
                    return {"status": "ok"}
                except Exception as e:
                    self.error(str(e))
                    self.call_service("persistent_notification/create", title="Room DB Update Failed", message=str(e))
                    return {"status": "error", "error": str(e)}
        ```

        **/config/packages/motion_lighting_v2/automations.yaml** (attribute reads + template condition):
        ```yaml
        automation:
          - alias: "Motion Lights — Bedroom (SQL-driven)"
            id: motion_lights_bedroom_sql
            trigger:
              - platform: state
                entity_id: binary_sensor.bedroom_motion_beta
                to: "on"
            variables:
              _raw: "{{ state_attr('sensor.room_configs_motion_lighting','payload') }}"
              _cfgs: "{{ _raw | from_json if _raw else {} }}"
              room_config: "{{ _cfgs.get('bedroom', {}) }}"
              timeout: "{{ room_config.get('timeout', 120) | int }}"
              bypass: "{{ room_config.get('bypass', false) | bool }}"
              presence_multiplier: "{{ room_config.get('presence_timeout_multiplier', 1.0) | float }}"
              is_presence_detected: "{{ is_state('person.evert','home') }}"
              effective_timeout: "{{ (timeout * presence_multiplier) | int if is_presence_detected else timeout }}"
              illuminance_threshold: "{{ room_config.get('illuminance_threshold', 10) | int }}"
            condition:
              - condition: template
                value_template: "{{ not bypass }}"
              - condition: template
                value_template: >
                  {{ (states('sensor.bedroom_illuminance_beta') | float(9999)) < illuminance_threshold }}
            action:
              - service: light.turn_on
                target:
                  entity_id: light.adaptive_bedroom_light_group
                data:
                  transition: 2
              - choose:
                  - conditions: "{{ is_state('binary_sensor.room_db_sqlite3_ok', 'on') }}"
                    sequence:
                      - service: shell_command.update_room_config
                        data:
                          room_id: "bedroom"
                          domain: "motion_lighting"
                          config_data: >-
                            {{ dict(room_config, **{'last_triggered': now().isoformat(), 'trigger_count': (room_config.get('trigger_count', 0) | int) + 1}) }}
                  - conditions: "{{ is_state('binary_sensor.room_db_sqlite3_ok', 'off') }}"
                    sequence:
                      - service: rest_command.room_db_update_config
                        data:
                          room_id: "bedroom"
                          domain: "motion_lighting"
                          config_data: >-
                            {{ dict(room_config, **{'last_triggered': now().isoformat(), 'trigger_count': (room_config.get('trigger_count', 0) | int) + 1}) }}
              - delay:
                  seconds: "{{ effective_timeout }}"
              - service: light.turn_off
                target:
                  entity_id: light.adaptive_bedroom_light_group
                data:
                  transition: 5
        ```

        **/config/packages/motion_lighting_v2/templates.yaml** (compatibility sensor):
        ```yaml
        template:
          - sensor:
              - name: "Motion Timeout — Bedroom (SQL)"
                unique_id: "motion_timeout_bedroom_sql"
                state: >-
                  {% set raw = state_attr('sensor.room_configs_motion_lighting','payload') %}
                  {% set cfg = (raw | from_json).get('bedroom', {}) if raw else {} %}
                  {{ cfg.get('timeout', 120) }}
                attributes:
                  bypass: >-
                    {% set raw = state_attr('sensor.room_configs_motion_lighting','payload') %}
                    {% set cfg = (raw | from_json).get('bedroom', {}) if raw else {} %}
                    {{ cfg.get('bypass', false) }}
                  last_triggered: >-
                    {% set raw = state_attr('sensor.room_configs_motion_lighting','payload') %}
                    {% set cfg = (raw | from_json).get('bedroom', {}) if raw else {} %}
                    {{ cfg.get('last_triggered', '') }}
                  room_id: "bedroom"
                  source: "room_database_sql"
        ```

        **/config/packages/vacuum_control_v2/scripts.yaml** (topic from input_text; JSON payload via tojson):
        ```yaml
        input_text:
          {{ valetudo_base_topic_var }}:
            name: "Valetudo Base Topic"
            min: 1
            max: 128
            initial: "valetudo/robot"
        script:
          clean_room_with_sql_tracking:
            alias: "Clean Room with SQL Database Tracking"
            fields:
              room:
                description: "Room to clean"
                required: true
                selector:
                  text:
            variables:
              _raw: "{{ state_attr('sensor.room_configs_vacuum_control','payload') }}"
              _cfgs: "{{ _raw | from_json if _raw else {} }}"
              room_config: "{{ _cfgs.get(room, {}) }}"
              segment_id: "{{ room_config.get('segment_id', 1) | int }}"
              base_topic: "{{ states('input_text.{{ valetudo_base_topic_var }}') }}"
            sequence:
              - service: mqtt.publish
                data:
                  topic: "{{ base_topic }}/MapSegmentationCapability/action/start_segment_action"
                  payload: "{{ {'action':'clean','segment_ids':[segment_id],'iterations':1,'customOrder':True} | tojson }}"
              - choose:
                  - conditions: "{{ is_state('binary_sensor.room_db_sqlite3_ok', 'on') }}"
                    sequence:
                      - service: shell_command.mark_room_cleaned
                        data:
                          room_id: "{{ room }}"
                  - conditions: "{{ is_state('binary_sensor.room_db_sqlite3_ok', 'off') }}"
                    sequence:
                      - service: rest_command.room_db_update_config
                        data:
                          room_id: "{{ room }}"
                          domain: "vacuum_control"
                          config_data: "{{ dict(room_config, **{'last_cleaned': now().isoformat(), 'needs_cleaning': false}) }}"
              - service: persistent_notification.create
                data:
                  title: "Vacuum Control"
                  message: "Started cleaning {{ room }} (segment {{ segment_id }})"
                  notification_id: "vacuum_{{ room }}"
        ```

        **/config/packages/vacuum_control_v2/mqtt_commands.yaml**:
        ```yaml
        # Intentionally minimal; base topic configured via input_text above.
        mqtt: {}
        ```

        **/config/.sql_room_db_tokens/README.txt**:
        - MIGRATION_TOKEN_SQLITE3_OK|MISSING
        - MIGRATION_TOKEN_JSON1_OK|MISSING

        **/config/secrets.example.yaml** (for operators who prefer to pre-seed input_text via UI):
        ```yaml
        # This file is illustrative; runtime templates do not read secrets directly.
        # Set input_text.{{ valetudo_base_topic_var }} from UI with this value if desired.
        {{ valetudo_base_topic_var }}: "valetudo/robot"
        ```

        Ensure ADR-0008 formatting and deterministic key order.
        CONFIDENCE: [n]%

    # PHASE 5 — Validation
    - id: sql_room_db.validation.comprehensive
      persona: strategos_gpt
      label: "Validation — Acceptance & Diagnostics"
      mode: validation_mode
      protocols: [production_grade_validation, adr_compliance_enforcement]
      bindings:
        - /mnt/data/ADR/ADR-0008-normalization-and-determinism-rules.md
      prompt: |
        Produce `validation_pack` including:
        - acceptance_criteria: DB init, JSON1 tokens present, SQL sensors have attribute payloads, transactional writes, schema guard, recorder excludes, ADR checks, and successful `homeassistant.check_config` on boot.
        - diagnostics_templates: Jinja to verify attribute presence and to parse fallback pseudo-JSON map when JSON1 is missing.
        - migration_tokens: ordered list with operator steps and expected file presence in {{ tokens_dir }}.
        - rollback_procedures and performance_benchmarks with concrete targets.
        CONFIDENCE: [n]%

  self_checks:
    - "Assert all SQL queries SELECT 'state'|'count' AND 'payload'; 'column:' is state|count; no JSON in state."
    - "Assert platform-level scan_interval == {{ scan_interval_seconds }} and entity_ids match globals.naming."
    - "Verify JSON1 preflight tokens exist; if missing JSON1, emit normalized schema + alternate sensors and adjust templates."
    - "Assert write paths are transactional; shell fallback uses heredoc + BEGIN IMMEDIATE/COMMIT + tojson; AppDaemon uses parameterized execute."
    - "Assert schema_version table exists and equals {{ schema_expected }} before any mutations."
    - "Assert recorder excludes include sensor.room_configs_* and sensor.rooms_needing_cleaning."
    - "Assert no runtime !secret usage in templates; base topic comes from input_text."
    - "Assert no unsupported Jinja helpers (e.g., path_exists) are used."
    - "Assert room_id matches {{ room_id_pattern }} and exists in {{ canonical_mapping_file }} (preferred path validation)."
    - "Assert writes respect rate limit and size cap; dry_run honored."
````
