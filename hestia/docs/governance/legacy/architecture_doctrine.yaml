meta:
  architecture_doctrine_v1.0:
    schema_version: '1.0'
    artifact_type: 'architecture_doctrine'
    identifier_key: id
    description: >
      Canonical schema for doctrinal principles used within the HESTIA architecture_doctrine.yaml artifact.
      Each doctrinal block defines a named structural or behavioral principle, scoped to a domain and tier.

    required_fields:
      - id
      - title
      - principle
      - rationale
      - tier
      - domain
      - status
      - metadata
      - confidence_metrics

    optional_fields:
      - example
      - guideline
      - metadata.tags
      - metadata.derived_from
      - metadata.contributors
      - metadata.deprecated

    field_definitions:
      id:
        type: string
        format: snake_case
        uniqueness: global
      title:
        type: string
        description: Human-readable name of the doctrinal rule
      principle:
        type: string
        description: Single declarative sentence describing the core rule
      rationale:
        type: string
        description: Explanation for why this rule exists and what it enforces
      tier:
        type: string
        format: greek_or_enum
        accepted_values: ['α', 'β', 'β+', 'γ', 'δ', 'ε', 'ζ', 'naming', 'abstraction']
      domain:
        type: string
        description: Logical or subsystem domain (e.g., motion, abstraction, metadata)
      status:
        type: string
        accepted_values: ['draft', 'proposed', 'approved', 'deprecated']
      example:
        type: object
        keys: ['good', 'avoid']
      guideline:
        type: string
      metadata:
        type: object
        required_fields:
          - created
          - last_updated
        optional_fields:
          - contributors
          - derived_from
          - tags
          - deprecated
        fields:
          created:
            type: date
            format: YYYY-MM-DD
          last_updated:
            type: date
            format: YYYY-MM-DD
          contributors:
            type: list
            item_type: string
          derived_from:
            type: string
          tags:
            type: list
            item_type: string
          deprecated:
            type: boolean
      confidence_metrics:
        type: object
        required_fields:
          - structural
          - operational
          - semantic
          - adoption_recommendation
        fields:
          structural:
            type: integer
            range: 0–100
          operational:
            type: integer
            range: 0–100
          semantic:
            type: integer
            range: 0–100
          adoption_recommendation:
            type: string
            accepted_values: ['ready_for_injection', 'needs_review', 'provisional', 'rejected']

    schema_validation_rules:
      - each id must be unique
      - each field must match expected type
      - tier must be from accepted list
      - example.good and example.avoid must be valid YAML if present
      - metadata.created and metadata.last_updated must be valid date strings
      - structural, operational, semantic → integer (0–100)
      - adoption_recommendation → one of:
        ['ready_for_injection', 'needs_review', 'provisional', 'rejected']

  architecture_doctrine_v1.1:
    schema_version: '1.1'
    artifact_type: architecture_doctrine
    identifier_key: id
    description: >
      Canonical schema for doctrinal principles used within the HESTIA architecture_doctrine.yaml artifact.
      Each doctrinal block defines a named structural or behavioral principle, scoped to a domain and tier.

    required_fields:
      - id
      - title
      - principle
      - rationale
      - tier
      - domain
      - status
      - metadata

    optional_fields:
      - example
      - guideline
      - metadata.tags
      - metadata.derived_from
      - metadata.contributors
      - metadata.deprecated
      - confidence_metrics

    field_definitions:
      id:
        type: string
        format: snake_case
        uniqueness: global
      title:
        type: string
        description: Human-readable name of the doctrinal rule
      principle:
        type: string
        description: Single declarative sentence describing the core rule
      rationale:
        type: string
        description: Explanation for why this rule exists and what it enforces
      tier:
        type: string
        format: greek_or_enum
        accepted_values: ['α', 'β', 'β+', 'γ', 'δ', 'ε', 'ζ', 'naming', 'abstraction']
      domain:
        type: string
        description: Logical or subsystem domain (e.g., motion, abstraction, metadata)
      status:
        type: string
        accepted_values: ['draft', 'proposed', 'approved', 'deprecated']
      example:
        type: object
        keys: ['good', 'avoid']
      guideline:
        type: string
      metadata:
        type: object
        required_fields:
          - created
          - last_updated
        optional_fields:
          - contributors
          - derived_from
          - tags
          - deprecated
        fields:
          created:
            type: date
            format: YYYY-MM-DD
          last_updated:
            type: date
            format: YYYY-MM-DD
          contributors:
            type: list
            item_type: string
          derived_from:
            type: string
          tags:
            type: list
            item_type: string
          deprecated:
            type: boolean
      confidence_metrics:
        type: object
        optional_fields:
          - structural
          - operational
          - semantic
          - adoption_recommendation
        fields:
          structural:
            type: integer
            range: 0-100
          operational:
            type: integer
            range: 0-100
          semantic:
            type: integer
            range: 0-100
          adoption_recommendation:
            type: string
            accepted_values: ['hold', 'internal_test', 'ready_for_injection', 'defer']

      validation:
        - each id must be unique
        - each field must match expected type
        - tier must be from accepted list
        - example.good and example.avoid must be valid YAML if present
        - metadata.created and metadata.last_updated must be valid date strings
        - confidence_metrics.structural, operational, semantic must be integers between 0 and 100

architecture_doctrine:
  - id: alias_reference_enforcement_001
    title: Alias-Only Reference Doctrine
    principle: >
      No logic, UI, or control may reference 'α'-layer entities directly. All references must go
      through validated aliases (β-layer or above).
    rationale: >
      Prevents fragility and coupling to hardware implementation. Supports substitutability, fallback
      logic, and metadata centralization.
    example:
      good: |
        'sensor.foxy_motion_score:
          source: binary_sensor.foxy_motion_beta'
      avoid: |
        'source: binary_sensor.foxy_motion_α'
        '#Breaks abstraction'
    tier: 'γ'
    domain: abstraction
    derived_from: phanes_generated_beta_light.yaml
    status: approved
    created: '2025-04-02'
    last_updated: '2025-04-02'
    contributors:
    - system
    tags:
    - abstraction
    - aliasing
    - doctrine
  - id: 'beta_identity_shift_001'
    title: Validated Abstractions Own Metadata
    principle: The β-layer (validated abstraction) should be the canonical source of truth for light identity and metadata, superseding the 'α'-layer and registries.
    rationale: Reduces drift, simplifies upstream logic, and aligns system behavior with operational reality. Validated entities are what users and automations actually reference.
    example:
      good: |
        light.foxy_beta:
          attributes:
            canonical_alpha: light.foxy
            model: 'Candle'
            manufacturer: 'Philips'
            firmware: '1.33.0'
      avoid: |
        'Treating the registry or physical device as the metadata authority
        core/light_device_registry.yaml holds primary metadata'
    tier: 'β+'
    domain: abstraction
    derived_from: phanes_generated_beta_light.yaml
    status: approved
    created: '2025-04-02'
    last_updated: '2025-04-02'
    contributors:
      - system
    tags:
      - metadata
      - abstraction
      - light
      - doctrine
  - id: metadata_registry_json_001
    title: JSON-Based Abstraction Registry
    principle: All β-layer abstraction metadata must be declared in 'beta_light_entities.json', not YAML fragments or device registries.
    rationale: Centralizes metadata, supports multi-alpha-device resolution, and ensures tooling compatibility.
    example:
      good: |
        {
          'bamboo_lamp_beta': {
            'canonical_alpha': [
              'light.bamboo_lamp',
              'light.bamboo_lamp_mtr'
            ],
            'firmware': '1.33.0',
            'model': 'Bamboo',
            'integration': ['Matter', 'Wiz']
          }
        }
      avoid: |
        light_device_registry.yaml
    tier: 'β+'
    domain: abstraction
    derived_from: hestia_beta_light_system_update.md
    status: approved
    created: '2025-04-02'
    last_updated: '2025-04-02'
    contributors:
      - system
    tags:
      - registry
      - metadata
      - json
      - abstraction
  - id: motion_aliasing_001
    tier: β
    domain: motion
    principle: Alias all motion sensors before logic usage
    guideline: |
      Always define 'binary_sensor.<room>_motion_β' as a template that aliases the actual PIR sensor.
    rationale: |
      Enables standardization, futureproofing, and traceability across installations.
    derived_from: abstraction_layers_unicode.yaml
  - id: tier_integrity_002
    tier:
      - 'γ'
      - 'δ'
    boolean_operator: 'OR'
    domain: abstraction
    principle: |
      Maintain strict one-tier dependencies
    guideline: |
      'γ' sensors should only consume β outputs. 'δ' layers must only decay 'γ' values. Never reference
      'α' in logic tiers.
    rationale: Ensures architectural purity and simplifies tier-specific debugging.
    derived_from: abstraction_layers_unicode.yaml
  - id: validation_chain_001
    tier: β/'γ'
    domain: validation
    principle: |
      Validation must mirror each abstraction transformation
    guideline: |
      For every alias or logic sensor, define a '*_validated' version that confirms the preceding
      layer is active, non-null, and semantically correct.
    rationale: |
      Guarantees each abstraction step is introspectable and automation-safe.
    derived_from: conversation_2025-04-01_validation_audit
  - id: validation_safe_introspection_002
    tier: diagnostic
    domain: validation
    principle: Validated sensors can be polled safely in diagnostics
    guideline: |
      Use '*_validated' sensors to expose availability without triggering any logic layers. Ideal
      for dashboards and monitoring.
    rationale: |
      Provides safe system state insight without automation interference.
    derived_from: conversation_2025-04-01_validation_audit
  - id: validation_sanity_check_003
    tier: 'γ'
    domain: sanity
    principle: Every computed sensor must pass a type and availability check
    guideline: Wrap 'γ'-layer outputs in a '*_sanity_checked' binary sensor to ensure values are defined and
      semantically valid.
    rationale: Prevents null propagation or invalid logic evaluation.
    derived_from: conversation_2025-04-01_validation_audit
  - id: validation_binary_output_004
    tier: validation
    domain: structure
    principle: Validation layers must resolve to binary states
    guideline: Implement all '*_validated' or '*_sanity_checked' logic as binary sensors with 'on/off' states.
    rationale: Simplifies downstream logic and validation semantics.
    derived_from: conversation_2025-04-01_validation_audit
  - id: motion_alias_template_patch_001
    tier: β
    domain: motion
    principle: Ensure all motion aliases are explicitly defined
    guideline: >
      Define 'binary_sensor.<room>_motion_β' aliases using template sensors that reference physical
      PIRs.
    rationale: >
      Prevents motion_score() from breaking due to undefined sources, and makes system substitutions
      declarative.
    derived_from: convo_003
  - id: 'presence_pipeline_abstraction_002'
    tier: 'ζ'
    domain: presence
    principle: Presence state should be derived from fused motion_score and occupancy layers
    guideline: |
      Construct 'binary_sensor.<room>_presence_ζ' using MSF outputs from '*_γ', '*_δ', and '*_validated'
      scores.
    rationale: |
      Centralizes presence logic in a composable, override-friendly, debuggable final abstraction
      layer.
    derived_from: convo_003
  - id: 'greek_suffix_naming_003'
    tier: naming
    domain: abstraction
    principle: Apply Greek tier suffixes to all abstracted entities
    guideline: >
      Tag abstracted/derived sensors using '_β', '_γ', '_δ', '_ε', '_ζ' to denote their transformation
      stage.
    rationale: >
      Clarifies abstraction level, enables tiered audits, and supports fusion pipelines.
    derived_from: convo_003
  - id: safe_json_attribute_parsing_001
    title: Safe JSON Attribute Parsing in Templates
    principle: >
      When accessing potentially JSON-formatted attributes from a Home Assistant entity, logic must first check
      if the attribute is a string before attempting to parse it with 'from_json'.
    rationale: >
      Prevents template crashes when attribute values are already dictionaries, missing, or malformed. Ensures
      consistent behavior across integrations and preserves template rendering in dashboards, sensors, or validators.
    tier: γ
    domain: templating
    status: approved
    example:
      good: |
        {% set input = state_attr('sensor.xyz', 'some_json') %}
        {% if input is string %}
          {% set config = input | from_json %}
        {% else %}
          {% set config = input %}
        {% endif %}
      avoid: |
        {% set config = state_attr('sensor.xyz', 'some_json') | from_json %}
    guideline: >
      Always pre-check attribute types before applying 'from_json'. Integrations that expose JSON as native
      Python objects (dicts) will break if this guard clause is omitted.
    metadata:
      created: 2025-06-10
      last_updated: 2025-06-10
      contributors:
        - promachos
      derived_from: architecture update.md
      tags:
        - templates
        - robustness
        - γ
    confidence_metrics:
      structural: 92
      operational: 89
      semantic: 95
      adoption_recommendation: ready_for_injection
  - id: alias_attribute_canonical_tracking_001
    title: Canonical Tracking via β-Tier Alias Attributes
    principle: >
      Assign α-tier canonical references using a 'canonical_id' attribute directly within the
      β-tier alias entity definition that wraps or abstracts them.
    rationale: >
      This approach preserves lineage at the point of abstraction, enables portable traceability,
      and avoids fragile external registries. It embeds relationship metadata in the configuration itself,
      ensuring resilience across deployments and runtime rehydration.
    tier: β
    domain: abstraction
    status: approved
    example:
      good: |
        binary_sensor:
          - name: 'Server Uptime (Alias)'
            unique_id: server_uptime_alias
            state: >
              {{ is_state('binary_sensor.server_uptime_raw', 'on') }}
            attributes:
              canonical_id: 'server_uptime_α'
      avoid: |
        {
          'binary_sensor.server_uptime_raw': {
            'canonical_id': 'server_uptime_α'
          }
        }
    guideline: >
      All validated β-tier abstractions must include a 'canonical_id' or equivalent lineage marker
      when referencing α-tier entities. Prefer inline attributes over external static files.
    metadata:
      created: 2025-06-10
      last_updated: 2025-06-10
      contributors:
        - promachos
      derived_from: DESIGN_PATTERNS.md
      tags:
        - aliasing
        - abstraction
        - β-tier
        - registry_elimination
    confidence_metrics:
      structural: 94
      operational: 91
      semantic: 96
      adoption_recommendation: ready_for_injection
  - id: template_library_tier_epsilon_001
    title: Template Library Must Contain Logic-Free, Deterministic Macros
    principle: >
      All reusable macros in 'template.library.jinja' must be logic-free, deterministic, and free of state mutation
      or side effects. Their only role is to encapsulate static transformation or evaluation logic.
    rationale: >
      Keeps the ε-tier reusable across sensors, automations, and validation systems. Prevents accidental recursion,
      state bleed, or environment drift in shared macros. Enables safe rehydration of compiled logic paths.
    tier: ε
    domain: templating
    status: approved
    example:
      good: |
        {% macro bool_gate(a, b) -%}
          {{ a == 'on' and b == 'on' }}
        {%- endmacro %}
      avoid: |
        {% macro set_state(entity, value) -%}
          {{ state_attr(entity, 'some_value') }}
          {% set states(entity) = value %}
        {%- endmacro %}
    guideline: >
      ε-tier macros must operate purely within the bounds of Jinja evaluation, with no implicit or explicit
      references to real-time state, 'set', or data mutation. They must be referentially transparent.
    metadata:
      created: 2025-06-10
      last_updated: 2025-06-10
      contributors:
        - promachos
      derived_from: template.library.jinja
      tags:
        - macros
        - ε-tier
        - deterministic
        - logic_free
    confidence_metrics:
      structural: 93
      operational: 92
      semantic: 97
      adoption_recommendation: ready_for_injection
  - id: config_integrity_rehoming_check_001
    title: Rehomed Configuration Files Must Pass Include Path Validation
    principle: >
      Any YAML file that is moved, renamed, or restructured must be validated against
      'configuration.yaml' and related includes ('sensor:', 'template:', 'binary_sensor:')
      to ensure compatibility and correct loading behavior.
    rationale: >
      Prevents integration failures, silent include omissions, and runtime errors
      due to outdated or broken file references. Reinforces traceability and structural discipline
      during reorganization or migration phases.
    tier: δ
    domain: configuration
    status: approved
    example:
      good: |
        # configuration.yaml
        sensor: !include_dir_merge_named hestia/sensors/alpha
      avoid: |
        # referencing removed or renamed files without updating include
        sensor: !include_dir_merge_named sensors/ (but sensors/ no longer exists)
    guideline: >
      All rehoming operations must include a validation step that:
      - Confirms presence under valid '!include' targets
      - Matches logical domain (e.g., 'sensor' block must not contain 'binary_sensor:')
      - Reflects tier-appropriate nesting
    metadata:
      created: 2025-06-10
      last_updated: 2025-06-10
      contributors:
        - promachos
      derived_from: ARCHITECTURE_DOCTRINE.yaml
      tags:
        - file_integrity
        - rehoming
        - include_structure
        - δ-tier
    confidence_metrics:
      structural: 90
      operational: 94
      semantic: 91
      adoption_recommendation: ready_for_injection
  - id: integrity_macro_001
    title: Macro-Based Entity Integrity Validation
    principle: >
      Use macros to dynamically validate that all declared entities in a subsystem are active and accounted for.
      Avoid hardcoded totals or static status strings that can become desynchronized from system state.
    rationale: >
      Provides real-time validation of subsystem health. Ensures consistency without relying on manual updates
      or static value assertions. Enhances resilience of deployment checks and aligns with tier-ε integrity surfaces.
    tier: 'ε'
    domain: validation
    status: proposed
    example:
      good: |
        sensor:
          - name: 'Hermes Package Integrity'
            state: >
              {{ macro('subsystem_entity_integrity', 'hermes', states('sensor.hermes_declared_total') | int).status }}
      avoid: |
        sensor:
          - name: 'Hermes Package Integrity'
            state: '42 entities loaded'  # Static and prone to drift
    guideline: >
      Declare reusable macros that cross-reference declared vs. active entities in a domain.
      Return structured diagnostic output ('.status', '.missing', '.percent_ok') to support
      tier-ε dashboard rendering or validation hooks.
    metadata:
      created: 2025-06-10
      last_updated: 2025-06-10
      contributors:
        - Evert
        - iris
      derived_from: conv_hestia_integrity_20250402
      tags:
        - macros
        - integrity
        - subsystem_validation
        - ε-tier
    confidence_metrics:
      structural: 94
      operational: 93
      semantic: 96
      adoption_recommendation: ready_for_injection
  - id: declared_entity_location_001
    title: Declared Entity Totals Must Reside in Tool Data Directories
    principle: >
      All generated sensors representing declared entity totals (e.g., '*_declared_total') must be stored
      under '/config/hestia/tools/<tool>/data/' and not alongside subsystem or domain packages.
    rationale: >
      Centralizes introspection logic and distinguishes system-generated metadata from human-authored configuration.
      Prevents namespace ambiguity and aligns with post-reboot configuration.yaml include rules and validator isolation.
    tier: ε
    domain: tooling
    status: proposed
    example:
      good: |
        # File: /config/hestia/tools/metis/data/hermes_declared_total_sensor.yaml
        sensor:
          - name: 'Hermes Declared Total'
            unique_id: 'hermes_declared_total'
            state: '{{ states | selectattr('entity_id','search','hermes') | list | count }}'
      avoid: |
        # Incorrect: co-located with logic layer config
        /config/hestia/logic/hermes_declared_total_sensor.yaml
    guideline: >
      All total-count introspection logic must route through '/tools/<tool>/data/' and
      be included via tool loader routines or test harnesses, not core 'configuration.yaml' includes.
      These should be excluded from '/hestia/logic', '/sensors', and '/templates' paths.
    metadata:
      created: 2025-06-10
      last_updated: 2025-06-10
      contributors:
        - iris
        - gizmo
      derived_from: conv_hestia_integrity_20250402
      tags:
        - metis
        - introspection
        - file_structure
        - ε-tier
    confidence_metrics:
      structural: 95
      operational: 92
      semantic: 94
      adoption_recommendation: needs_review
      user_comments: review data sensor pathway for proper inclusion by configuration.yaml
  - id: tooling_launch_interface_001
    title: Tool Modules Must Expose Canonical 'launch_<tool>.py' Entrypoints
    principle: >
      Each HESTIA tool must provide a CLI-friendly script named 'launch_<tool>.py' as its sole interface
      for automated invocation and system-level integration.
    rationale: >
      Standardizes entrypoint discovery and tooling contract enforcement. Supports transparent shell invocation,
      CLI automation, and safe isolation from inline Python logic that may mutate runtime environments.
    tier: γ
    domain: tooling
    status: approved
    example:
      good: |
        shell_command:
          launch_phanes: python3 /config/hestia/tools/phanes/launch_phanes.py
      avoid: |
        shell_command:
          launch_phanes: python3 -c 'from tools.phanes import run_all; run_all()'
    guideline: >
      Every tooling module (e.g., 'mnemosyne', 'phanes', 'iris', 'metis') must expose a top-level script
      named 'launch_<tool>.py' and include it in the tool manifest. These scripts must support positional
      arguments, exit codes, and output logging, and be callable without side effects.
    metadata:
      created: 2025-06-10
      last_updated: 2025-06-10
      contributors:
        - iris
        - promachos
      derived_from: system interface audit 2025-04-02
      tags:
        - tooling
        - shell_interface
        - γ-tier
        - cli
    confidence_metrics:
      structural: 95
      operational: 96
      semantic: 94
      adoption_recommendation: ready_for_injection
  - id: tools_structure_001
    title: Canonical Directory Convention for Tooling Modules
    principle: >
      All functional tools must reside under '/config/hestia/tools', with one subdirectory per subsystem.
      No tool logic should exist outside this path or be stored as isolated scripts in '/config/' or '/tools/'.
    rationale: >
      Ensures a modular, discoverable structure that aligns with tier-based encapsulation. Prevents configuration
      sprawl, enforces manifest-based tool registration, and simplifies lifecycle integration for testing,
      documentation, and CI/CD.
    tier: γ
    domain: tooling
    status: proposed
    example:
      good: |
        /config/hestia/tools/charon/
        /config/hestia/tools/iris/
        /config/hestia/tools/legacy/
      avoid: |
        /config/tools/charon.py
        /config/tools/generate_light_templates.py
    guideline: >
      Tools must declare their canonical root under '/config/hestia/tools/<tool_name>/' and be registered
      in the 'tool_manifest.yaml'. This enables dynamic CLI wiring, file validation, and structured interface
      exposure for automation harnesses and prompts.
    metadata:
      created: 2025-06-10
      last_updated: 2025-06-10
      contributors:
        - gizmo
        - iris
      derived_from: conv_20250402_tool_refactor
      tags:
        - modularization
        - directory_structure
        - γ-tier
    confidence_metrics:
      structural: 96
      operational: 93
      semantic: 95
      adoption_recommendation: ready_for_injection
  - id: tier_chain_reference_enforcement_001
    title: Tier Chain Reference Enforcement (β→ζ)
    principle: >
      Each tier must explicitly reference its immediate predecessor in the signal abstraction chain: β → γ → δ → ζ.
    rationale: >
      Ensures layered logic does not bypass intermediate inference layers, preserving override and diagnostic fidelity.
    tier: all
    domain: layering
    status: approved
    metadata:
      created: 2025-06-10
      last_updated: 2025-06-10
      contributors: [promachos]
      derived_from: hestia_v7_metadata_standardization.md
      tags: [tiering, traceability, abstraction]
    confidence_metrics:
      structural: 96
      operational: 93
      semantic: 96
      adoption_recommendation: ready_for_injection
  - id: tier_registry_consistency_001
    title: Tier-Scoped Registry Consistency
    principle: >
      Tiered entities (β and above) must encode their signal lineage using structured attributes and maintain consistency with the canonical room-sensor registry.
    rationale: >
      Prevents desynchronization between logic abstractions and physical signal sources during system updates.
    tier: β
    domain: registry
    status: approved
    metadata:
      created: 2025-06-10
      last_updated: 2025-06-10
      contributors: [iris]
      derived_from: hestia_v7_sensor_migration.md
      tags: [registry, lineage, tier-consistency]
    confidence_metrics:
      structural: 95
      operational: 90
      semantic: 95
      adoption_recommendation: ready_for_injection
  - id: versioning_policy_001
    title: Semantic Versioning Enforcement in Metadata
    principle: >
      All components and configuration files must declare a 'version' attribute following semantic versioning (MAJOR.MINOR.PATCH), with each change updating the 'last_updated' field in ISO format.
    rationale: >
      Guarantees traceability of changes and automated detection of version drift during CI/CD validations.
    tier: ε
    domain: versioning
    status: approved
    metadata:
      created: 2025-06-10
      last_updated: 2025-06-10
      contributors: [promachos]
      derived_from: hestia_v7_metadata_standardization.md
      tags: [versioning, changelog, ε-tier]
    confidence_metrics:
      structural: 96
      operational: 92
      semantic: 94
      adoption_recommendation: ready_for_injection
  - id: canonical_id_migration_integrity_001
    title: Canonical ID Preservation During Migration
    principle: >
      Canonical identifiers must persist across refactoring events and remain present in the destination entity under the 'canonical_id' attribute.
    rationale: >
      Maintains long-term traceability and prevents loss of lineage through abstraction layering.
    tier: all
    domain: migration
    status: approved
    metadata:
      created: 2025-06-10
      last_updated: 2025-06-10
      contributors: [promachos]
      derived_from: hestia_v7_metadata_standardization.md
      tags: [lineage, migration, metadata]
    confidence_metrics:
      structural: 97
      operational: 94
      semantic: 96
      adoption_recommendation: ready_for_injection
  - id: signal_plane_abstraction_001
    title: Signal Plane Must Be Abstracted Before Logic Use
    principle: >
      Physical integration entities (α-tier) must never be used directly in γ-tier logic or δ-tier automation. All paths must flow through structured β-tier abstractions.
    rationale: >
      Reduces fragility and hardware coupling while allowing for template modularity and fallback strategies.
    tier: all
    domain: abstraction
    status: approved
    metadata:
      created: 2025-06-10
      last_updated: 2025-06-10
      contributors: [iris]
      derived_from: hestia_v7_signal_plane_guide.md
      tags: [signal-plane, tiering, abstraction]
    confidence_metrics:
      structural: 96
      operational: 91
      semantic: 95
      adoption_recommendation: ready_for_injection
  - id: configuration_structure_rules_001
    title: Tier-First Directory and Load Structure
    principle: >
      All entities must be organized first by tier, then by domain, with 'configuration.yaml' includes respecting this load order to ensure dependency integrity.
    rationale: >
      Simplifies onboarding, validation, and runtime debugging by aligning loading behavior with architectural design.
    tier: all
    domain: configuration
    status: approved
    metadata:
      created: 2025-06-10
      last_updated: 2025-06-10
      contributors: [iris]
      derived_from: hestia_v7_target_architecture.md
      tags: [directory-structure, loading, tiering]
    confidence_metrics:
      structural: 96
      operational: 92
      semantic: 93
      adoption_recommendation: ready_for_injection
  - id: entity_attribute_minimal_001
    title: Minimal Attribute Set for All Entities
    principle: >
      All entities must include core attributes for subsystem alignment, versioning, and changelog history: 'subsystem', 'version', 'last_updated', and 'origin_file'.
    rationale: >
      Ensures every entity is auditable and traceable as part of the configuration base.
    tier: all
    domain: metadata
    status: approved
    metadata:
      created: 2025-06-10
      last_updated: 2025-06-10
      contributors: [iris]
      derived_from: hestia_v7_metadata_standardization.md
      tags: [attributes, traceability, metadata]
    confidence_metrics:
      structural: 97
      operational: 94
      semantic: 95
      adoption_recommendation: ready_for_injection
  - id: validator_trace_presence_001
    title: All Validation Chains Must Provide Traceable Evidence
    principle: >
      Each validation chain must include at least one traceable outcome or artifact, such as a validator log ID or scenario-based test result.
    rationale: >
      Ensures that all configuration checks, automation validations, and macro execution paths
      can be independently confirmed through recorded outcomes or auditable diagnostics.
    tier: ε
    domain: validation
    status: approved
    metadata:
      created: 2025-06-10
      last_updated: 2025-06-10
      contributors:
        - system
        - promachos
      derived_from: hestia_v7_canonical_artifact_reference_guide.md
      tags:
        - validator
        - diagnostics
        - ε-tier
        - traceability
    confidence_metrics:
      structural: 97
      operational: 95
      semantic: 96
      adoption_recommendation: ready_for_injection
  - id: metadata_bracketing_safety_001
    title: Bracket Service and Template References in Metadata Strings
    principle: >
      All service calls, script names, or template constructs referenced in metadata fields must be enclosed
      in [domain] syntax to prevent entity parsing and execution by Home Assistant.
    rationale: >
      Prevents accidental evaluation or UI interpretation of sensitive metadata strings. Ensures
      that changelogs, documentation sensors, and state overlays remain inert and informative,
      not operationally active.
    tier: ε
    domain: metadata
    status: approved
    example:
      good: '[shell_command] ensure_documenter_script'
      avoid: 'shell_command.ensure_documenter_script'
    guideline: >
      Bracket domain-prefixed identifiers in non-executable fields such as changelogs,
      template comments, or metadata-driven display strings. Applies especially to
      'input_text', 'markdown_card', 'template.yaml', and 'sensor.*_changelog' usage.
    metadata:
      created: 2025-06-10
      last_updated: 2025-06-10
      contributors:
        - promachos
      derived_from: architecture update.md
      tags:
        - metadata
        - safety
        - display-layer
        - ε-tier
    confidence_metrics:
      structural: 93
      operational: 91
      semantic: 95
      adoption_recommendation: ready_for_injection
  - id: tiered_unit_propagation_001
    title: Propagate Units and Logic Gradually Through Tiers
    principle: >
      Unit of measurement and logical transformations should originate from β- or γ-tier entities
      and flow upward tier-by-tier.
    rationale: >
      Ensures logic evolution remains layered, auditable, and reversible. Prevents sudden jumps
      that obscure entity provenance and transformation lineage.
    tier: γ
    domain: abstraction
    status: proposed
    example:
      good: |
        sensor.motion_score_γ:
          unit_of_measurement: 'score'
          derived_from: sensor.motion_score_β
      avoid: |
        sensor.motion_score_ε:
          derived_from: motion_score_α
    metadata:
      created: 2025-06-10
      contributors:
        - promachos
      derived_from: hestia_v7_signal_plane_guide.md
      tags:
        - tiered-logic
        - signal-plane
        - layering
    confidence_metrics:
      structural: 96
      operational: 94
      semantic: 96
      adoption_recommendation: ready_for_review
  - id: derived_from_consistency_validation_001
    title: Validating 'derived_from' Consistency
    principle: >
      All 'derived_from' references must resolve to a valid canonical entity ID present within the
      current Source of Semantic Truth (SSSoT) version. This ensures structural soundness and
      maintains referential traceability.
    rationale: >
      Prevents misaligned references that could bypass tier logic, break dependency chains,
      or generate invalid linkages between signals.
    tier: γ
    domain: metadata
    status: proposed
    example:
      good: |
        sensor.motion_score_γ:
          derived_from: sensor.motion_score_β
      avoid: |
        sensor.motion_score_γ:
          derived_from: motion_score
    metadata:
      created: 2025-06-10
      contributors:
        - promachos
      derived_from: hestia_v7_signal_plane_guide.md
      tags:
        - consistency
        - validation
        - entity-linking
    confidence_metrics:
      structural: 94
      operational: 92
      semantic: 95
      adoption_recommendation: ready_for_review
  - id: alpha_naming_misuse_prevention_001
    title: Avoid Template Aliases that Simulate '_α' Naming
    principle: >
      '_α'-suffixed names must only be used for physical-tier entities. Creating template-based aliases
      with '_α' suffixes introduces architectural rot and breaks tier clarity.
    rationale: >
      Prevents logic misdirection, inaccurate lineage, and the erosion of signal plane integrity. Ensures
      '_α' designations remain strictly reserved for hardware-sourced or integration-originated entities.
    tier: β
    domain: abstraction
    status: proposed
    example:
      good: |
        # Physical entity correctly referenced
        sensor.foxy_motion_α:
          platform: integration
      avoid: |
        # Template simulating raw tier naming (anti-pattern)
        sensor.foxy_motion_α:
          platform: template
          value_template: '{{ states('binary_sensor.foxy_motion') }}'
    metadata:
      created: 2025-06-10
      contributors:
        - promachos
      derived_from: conversation_2025-04-13.md
      tags:
        - sensor abstraction
        - tier violation
        - entity_registry
        - architecture hygiene
    confidence_metrics:
      structural: 95
      operational: 95
      semantic: 97
      adoption_recommendation: inject_immediately
  - id: alpha_entity_naming_protocol_001
    title: Proper Renaming of '_α' Tier Entities
    principle: >
      '_α'-suffixed names must only be used for physical-tier entities. These must be renamed through their origin
      systems or Home Assistant registry, not simulated via templates or aliases.
    rationale: >
      Guarantees that '_α' labels accurately reflect raw, hardware-bound sources. Prevents leakage of abstraction
      layers and preserves the semantic tier contract.
    tier: α
    domain: signal-plane
    status: proposed
    metadata:
      origin: conversation_2025-04-13.md
      context: sensor entity renaming protocol and abstraction enforcement
      tags:
        - tier enforcement
        - entity registry
        - abstraction integrity
        - resilience
        - naming policy
      contributor: gpt_architect
      created: 2025-06-10
    confidence_metrics:
      structural: 96
      operational: 95
      semantic: 97
      adoption_recommendation: ready_for_injection
    guideline: |
      To properly assign '_α' naming:
        1. **YAML-defined**: Rename via 'name:' or 'object_id:' field in the integration config
        2. **UI-defined**: Rename using “Entity ID” field in the Home Assistant UI
        3. **Registry-defined**: Edit '/config/.storage/core.entity_registry' while HA is **stopped**
          and change the ''entity_id'' field directly.

      '⚠️' Never simulate '_α' names using templates. Templates imply '_β' or higher tiers.
  - id: 'missingid_001'
    title: Proper Renaming of '_\u03b1' Tier Entities
    principle: >
      '_\u03b1' identifiers must be applied exclusively to physical/integration-origin entities. Valid reassignment
      should be conducted via integration config, UI edit, or direct registry update while Home Assistant is offline.
    rationale: >
      This preserves the semantic integrity of physical truth tiers. Template-based simulations must instead use
      '_\u03b2' or higher suffixes to reflect their abstraction tier.
    tier: α
    domain: semantics
    status: proposed
    metadata:
      created: 2025-06-10
      contributors:
        - gpt_architect
      derived_from: conversation_2025-04-13.md
      tags:
        - tier enforcement
        - entity registry
        - abstraction integrity
        - resilience
        - naming policy
    confidence_metrics:
      structural: 97
      operational: 95
      semantic: 98
      adoption_recommendation: ready_for_injection
  - id: generated_tool_metadata_001
    title: Tool Metadata Must Reside in 'core/generated/'
    principle: >
      Any sensors that describe introspective tool metadata, file timestamps,
      or build diagnostics (e.g. Clio, Iris, Patchloader) must be placed in
      'core/generated/' and assigned to tier 'ε'.
    rationale: >
      This separates human-authored configuration from auto-generated
      telemetry, avoids merge conflicts, and preserves programmatic rebuildability.
    tier: ε
    domain: tooling
    derived_from: conversation_2025-04-09.md
    status: proposed
    created: 2025-04-09
    contributors:
      - gpt_architect
    tags:
      - telemetry
      - tooling
      - core
  - id: subsystem_diagnostics_tier_epsilon
    title: Diagnostics Sensors Must Use Tier ε
    principle: >
      All sensors that perform diagnostics, validation, or meta-monitoring
      of subsystems must be declared with tier 'ε'.
    rationale: >
      These sensors are meta-level observers and must remain detached from tiered logic,
      to avoid recursive dependency chains or invalid telemetry loops.
    tier: ε
    domain: diagnostics
    derived_from: conversation_2025-04-09.md
    status: proposed
    created: 2025-04-09
    contributors:
      - gpt_architect
    tags:
      - monitoring
      - diagnostics
      - tiering
  - id: template_variable_guard_001
    title: 'Template Variable Guards are Mandatory'
    principle: >
      All dynamically resolved entity references must be cast to strings or protected with
      'default', 'expand', or 'is_defined' checks before being passed into 'is_state()' or similar functions.
    rationale: >
      Prevents runtime crashes in automations and scripts due to undefined variables or null sensors.
    tier: γ
    domain: template safety
    status: proposed
    example:
      good: |
        {% set family_list = expand('group.family') | list %}
        {% set person = family_list[0] if family_list|length > 0 else 'person.evert' %}
        {% set gps = is_state(person, 'home') %}
      avoid: |
        {% set gps = is_state(person, 'home') %}  # 'person' may be undefined
    metadata:
      created: 2025-04-16
      contributors:
        - gpt_architect
      derived_from: conversation_2025-04-16.md
      tags:
        - template
        - jinja
        - logic
        - error-prevention
    confidence_metrics:
      structural: 95
      operational: 94
      semantic: 96
      adoption_recommendation: ready_for_injection
  - id: diagnostic_map_namespace_loop_001
    title: 'Use Namespaced Jinja Loops for Diagnostic Maps'
    principle: >
      When constructing room-by-room sensor evaluations in Jinja templates,
      use a 'namespace()' object to build up dictionaries incrementally.
    rationale: >
      This prevents scoping issues during template evaluation and supports predictable,
      composable diagnostic payloads suitable for 'tojson' emission.
    tier: γ
    domain: template safety
    status: proposed
    example:
      good: |
        {% set ns = namespace(data={}) %}
        {% for room in rooms %}
          {% set result = ... %}
          {% set ns.data = dict(ns.data.items() | list + [(room, result)]) %}
        {% endfor %}
        {{ ns.data | tojson }}
    metadata:
      created: 2025-06-10
      contributors:
        - gpt_architect
      derived_from: conversation_2025-04-09.md
      tags:
        - jinja
        - diagnostics
        - namespace
    confidence_metrics:
      structural: 94
      operational: 91
      semantic: 95
      adoption_recommendation: ready_for_injection
  - id: automation_id_and_trigger_guidance_001
    title: 'Avoid Duplicate Automation IDs and Prefer trigger: Format'
    principle: >
      Automations must use 'trigger:' and 'action:' keys rather than their plural forms,
      and IDs must be unique across the configuration surface.
    rationale: >
      Prevents config corruption during reload and ensures validation safety in large-scale
      setups. Promotes schema alignment for linting and audit tools.
    tier: δ
    domain: automation
    status: proposed
    metadata:
      created: 2025-06-10
      contributors:
        - gpt_architect
      derived_from: conversation_2025-04-09.md
      tags:
        - automation
        - validation
        - naming
    confidence_metrics:
      structural: 93
      operational: 90
      semantic: 94
      adoption_recommendation: ready_for_review
  - id: template_variable_guard_examples_001
    title: Defensive Jinja Templates in Automation
    principle: >
      All automation and script templates that use dynamically referenced entity variables must:
      - Cast identifiers to strings when unresolved
      - Use 'default(...)', 'expand(...)', or 'first(...)' to provide safe fallbacks
      - Avoid passing raw variables to 'is_state()' unless guaranteed defined
    rationale: >
      Prevents runtime crashes due to undefined variables and ensures automation resilience
      during startup and dynamic resolution contexts (e.g., presence, groups, composite templates).
    tier: γ
    domain: template safety
    status: proposed
    example:
      good: |
        {% set defined_members = expand('group.family') | selectattr('state', 'defined') | map(attribute='entity_id') | list %}
        {% set person = defined_members[0] if defined_members|length > 0 else 'person.fallback' %}
        {% set gps = is_state(person, 'home') %}
      avoid: |
        {% set gps = is_state(person, 'home') %}  # person might be undefined
    metadata:
      created: 2025-06-10
      contributors:
        - promachos
      derived_from: conversation_2025-04-09.md
      tags:
        - template
        - error-prevention
        - jinja
        - logic safety
    confidence_metrics:
      structural: 95
      operational: 93
      semantic: 96
      adoption_recommendation: ready_for_review
  - id: tier_purity_enforcement_β_alias
    title: 'Strict Role Separation Between β Aliases and η Composites'
    principle: >
      Tier β is reserved exclusively for 1:1 pure aliases to α-tier sensors. Any formatting,
      merging, or logic must be escalated to η-tier.
    rationale: >
      Maintaining β as a pure alias tier prevents architectural confusion, enforces stability,
      and upholds traceable sensor provenance.
    example:
      good: |
        binary_sensor.kitchen_motion_β:
          state: '{{ states('binary_sensor.kitchen_motion_α') }}'
      avoid: |
        binary_sensor.kitchen_motion_β:
          state: '{{ is_state('binary_sensor.motion_1_α', 'on') or is_state('binary_sensor.motion_2_α', 'on') }}'
    tier: 'β'
    domain: 'tiering'
    derived_from: 'conversation_2025-04-09.md'
    status: 'proposed'
    created: '2025-04-09'
    contributors: ['gpt_architect', 'evert']
    tags: ['tiering', 'aliasing', 'sensor integrity']
  - id: eta_tier_formatting_limits_001
    title: 'η-tier Sensors: Use for Lightweight Composition and Formatting'
    principle: >
      Use the η tier ('_η') to create lightweight abstractions that combine or format raw data,
      but do not implement scoring or decision logic, which belongs to γ/δ/ε tiers.
    rationale: >
      Ensures architectural separation between passive formatting (η) and active logic (γ+),
      maintaining auditability and simplifying fault tracing in sensor pipelines.
    example:
      good: |
        binary_sensor.bedroom_occupancy_η:
          state: >
            {{ is_state('binary_sensor.bed_α', 'on') or
              is_state('binary_sensor.motion_α', 'on') }}
          attributes:
            canonical_id: 'binary_sensor_bedroom_occupancy_η'
            tier: 'η'
      avoid: |
        binary_sensor.bedroom_occupancy_η:
          state: >
            {{ 75 if is_state('binary_sensor.motion_α', 'on') else 0 }}
    tier: 'η'
    domain: 'sensor composition'
    derived_from: 'conversation_2025-04-13.md'
    status: 'proposed'
    created: '2025-04-13'
    contributors: ['gpt_architect', 'evert']
    tags: ['composition', 'tiering', 'signal formatting']
  - id: mu_tier_metadata_tracking_001
    title: 'Use μ-tier Metadata to Track Dependencies and Tags'
    principle: >
      μ-tier sensors serve as metadata carriers for architectural introspection,
      documenting relationships, tags, and diagnostic coverage without participating in live signal flows.
    rationale: >
      Establishes a non-evaluative tier for documenting signal lineage, tier mapping, and fusion dependencies,
      improving toolchain introspection, schema linting, and audit traceability.
    example:
      good: |
        sensor.presence_fusion_metadata_μ:
          state: 'active'
          attributes:
            tags: ['presence', 'fusion', 'ζ']
            depends_on: ['sensor.motion_score_γ', 'binary_sensor.presence_threshold_ε']
            tier: 'μ'
    tier: 'μ'
    domain: 'metadata'
    derived_from: 'conversation_2025-04-13.md'
    status: 'proposed'
    created: '2025-04-13'
    contributors: ['gpt_architect', 'evert']
    tags: ['metadata', 'linting', 'fusion tracking', 'tier μ']
  - id: presence_confidence_weighted_fallback_001
    title: 'Compute Presence Confidence with Weighted Inputs'
    principle: >
      When presence must be inferred from fallback signals (e.g., GPS, WiFi, activity),
      a 'confidence_map' pattern should be used to score inputs by relevance and sum them.
    rationale: >
      Maintains transparency of signal priority, enforces consistent weighting,
      and improves resilience of fallback detection when primary sensors are unavailable.
    example:
      good: |
        {% set confidence_map = {
          'gps': 50,
          'wifi': 20,
          'floor_activity': 15,
          'distance': 10,
          'direction': 5
        } %}
        {% set total = 0 %}
        {% for method, active in fallback_methods.items() %}
          {% if active %}
            {% set total = total + confidence_map[method] %}
          {% endif %}
        {% endfor %}
        {{ total }}
    tier: 'δ'
    domain: 'presence'
    derived_from: 'conversation_2025-04-09.md'
    status: 'proposed'
    created: '2025-04-09'
    contributors: ['gpt_architect', 'evert']
    tags: ['presence', 'fallback', 'confidence scoring']
  - id: beta_entity_reference_declaration_001
    title: Entity Attribute 'entity:' Must Reference Source Device
    principle: >
      β-tier sensors must explicitly declare their source entity using the 'entity:' field,
      referring to an upstream integration entity such as a 'device_tracker', 'sensor', or 'person'.
    rationale: >
      Reinforces tier traceability, improves diagnostics, and supports tooling that audits signal origin paths.
    example:
      good: |
        binary_sensor.user_presence_β:
          entity: device_tracker.iphone14
    tier: 'β'
    domain: 'traceability'
    derived_from: 'conversation_2025-04-09.md'
    status: 'proposed'
    created: '2025-04-09'
    contributors: ['gpt_architect', 'evert']
    tags: ['entity declaration', 'traceability', 'β-tier']
  - id: canonical_id_suffix_tier_alignment_001
    title: 'Canonical ID Suffix Must Reflect Tier Symbol'
    principle: >
      Every 'canonical_id' must end with the correct Greek tier symbol (e.g. '_β', '_γ', '_ε')
      corresponding to the sensor or logic entity’s designated tier.
    rationale: >
      Enforces semantic traceability across the stack and supports automated tooling
      for tier validation, registry linting, and architectural constraint checking.
    example:
      good: |
        - home_macbook_distance_alias_β
        - bedroom_occupancy_validated_ε
        - living_room_presence_fusion_ζ
      avoid: |
        - sensor_living_room_presence_validated   # missing suffix
        - sensor.kitchen_occupancy_gamma          # wrong style
    tier: 'μ'
    domain: 'naming'
    derived_from: 'conversation_2025-04-09.md'
    status: 'proposed'
    created: '2025-04-09'
    contributors: ['gpt_architect', 'evert']
    tags: ['canonical_id', 'tier validation', 'naming', 'registry compliance']
    confidence_metrics:
      structural: 95
      operational: 92
      semantic: 96
      adoption_recommendation: ready_for_injection
  - id: naming_convention_id_vs_name_001
    title: 'Use Underscores for Unique IDs, Title Case for Names'
    principle: >
      'unique_id' must use 'snake_case', while 'name' must use 'Title Case' with spaces.
      Avoid mixing formats or applying the wrong convention to the wrong key.
    rationale: >
      Enforces consistent schema formatting, improves UI rendering across platforms,
      and supports predictable parsing in tooling.
    example:
      good: |
        unique_id: living_room_motion_score_gamma
        name: Living Room Motion Score Gamma
      avoid: |
        unique_id: LivingRoomMotionScoreGamma
        name: living_room_motion_score_gamma
    tier: 'μ'
    domain: 'naming'
    derived_from: 'conversation_2025-04-09.md'
    status: 'proposed'
    created: '2025-04-09'
    contributors: ['gpt_architect']
    tags: ['naming', 'parsing', 'ui consistency']
    confidence_metrics:
      structural: 96
      operational: 94
      semantic: 95
      adoption_recommendation: ready_for_injection
  - id: source_file_traceability_003
    title: 'All Sensor Definitions Must Include a Traceable Source File'
    principle: >
      Every sensor in the system must include its original YAML file path during validation,
      export, and metadata enrichment phases.
    rationale: >
      Enables reproducibility, subsystem-level debugging, and full auditability across tiered repositories
      and documentation surfaces. Supports macro validation and rollback infrastructure.
    tier: 'μ'
    domain: 'validation'
    derived_from: 'conversation_2025-04-15'
    status: 'proposed'
    created: '2025-04-15'
    contributors: ['sensor_mapper']
    tags: ['validation', 'traceability', 'source_files']
    confidence_metrics:
      structural: 95
      operational: 92
      semantic: 94
      adoption_recommendation: ready_for_injection
  - id: name_does_not_imply_tier_001
    title: 'Dont Trust the Name — Verify Sensor Logic'
    principle: >
      Entity names are not sufficient indicators of their tier or function. Sensor tier must be
      inferred from actual logic, dependencies, and role within abstraction chains—not from
      naming conventions alone.
    rationale: >
      Prevents incorrect tier classification and architectural drift caused by misplaced trust in naming alone.
      Reinforces audit-first workflows, requiring semantic verification during registry updates and validation sweeps.
    tier: 'μ'
    domain: 'tier classification'
    derived_from: 'conversation_2025-04-12.md'
    status: 'proposed'
    created: '2025-04-12'
    contributors: ['gpt_architect']
    tags: ['naming', 'tier enforcement', 'validation', 'registry logic']
    confidence_metrics:
      structural: 96
      operational: 94
      semantic: 97
      adoption_recommendation: ready_for_injection
  - id: sensor_file_path_metadata_001
    title: 'Sensor Definitions Must Include File Path Metadata'
    principle: >
      Every sensor configuration must include a 'file:' attribute in its metadata block,
      capturing the absolute path rooted in '/config'. This value must be inserted only during
      validated parsing or export workflows.
    rationale: >
      Enables traceability, validation consistency, and downstream ingestion by audit pipelines
      and third-party infrastructure. Discourages speculative path attribution.
    tier: 'μ'
    domain: 'metadata'
    derived_from: 'conversation_2025-04-13.md'
    status: 'proposed'
    created: '2025-04-13'
    contributors: ['gpt_architect']
    tags: ['metadata', 'source tracking', 'validation', 'sensor attribution']
    confidence_metrics:
      structural: 97
      operational: 96
      semantic: 95
      adoption_recommendation: ready_for_injection
  - id: macro_reference_tier_alignment_001
    title: 'Avoid Direct Macro References to α-tier in γ-tier Sensors'
    principle: >
      Sensors that invoke macros (e.g., 'motion_score()') in γ-tier logic must reference properly tiered β aliases,
      not direct α-layer devices.
    rationale: >
      Preserves abstraction integrity and ensures that logic flows through expected tier chains. Prevents macro misuse
      that bypasses architectural encapsulation.
    example:
      good: |
        sensor.motion_score_γ:
          value_template: '{{ motion_level('binary_sensor.motion_β') }}'
      avoid: |
        sensor.motion_score_γ:
          value_template: '{{ motion_score('binary_sensor.kitchen_motion_sensor_α') }}'
    tier: 'γ'
    domain: 'macro tiering'
    derived_from: 'developer_guidelines.md'
    status: 'proposed'
    created: '2025-06-10'
    contributors: ['gpt_architect']
    tags: ['macros', 'tiering', 'validation']
    confidence_metrics:
      structural: 95
      operational: 93
      semantic: 96
      adoption_recommendation: ready_for_injection
  - id: undefined_variable_template_crash_001
    title: 'Prevent Crashes from Undefined Template Variables'
    principle: >
      All template logic referencing dynamic variables (e.g., 'person') must guard against undefined values
      using '| string', 'default(...)', or 'expand(...)'.
    rationale: >
      Prevents fatal runtime errors such as 'UndefinedError: 'person' is undefined' in automations or presence calculations.
      Encourages use of resilient template structures in tiered logic blocks.
    example:
      good: |
        {% set gps = is_state(person | string, 'home') %}
        {% set family_list = expand('group.family') | list %}
        {% set person = family_list[0] if family_list|length > 0 else 'person.evert' %}
      avoid: |
        {% set gps = is_state(person, 'home') %}
    tier: 'γ'
    domain: 'template safety'
    derived_from: 'conversation_2025-04-16.md'
    status: 'proposed'
    created: '2025-06-10'
    contributors:
      - gpt_architect
    tags:
      - template error
      - presence
      - jinja
      - undefined variable
    confidence_metrics:
      structural: 95
      operational: 94
      semantic: 96
      adoption_recommendation: ready_for_injection
  - id: 'numeric_state_float_guard_001'
    title: 'Always Use float(0) for Numeric State Reads'
    principle: >
      All numeric values retrieved using 'states()' must be cast with '| float(0)'
      to avoid evaluation errors from unavailable or non-numeric sensor states.
    rationale: >
      Prevents runtime failures in templates that depend on numeric evaluations by
      enforcing default fallback casting to zero.
    example:
      good: |
        {% set temp = states('sensor.kitchen_temperature_β') | float(0) %}
      avoid: |
        {% set temp = states('sensor.kitchen_temperature_β') | float %}
    tier: 'γ'
    domain: 'template safety'
    status: 'approved'
    created: '2025-06-10'
    contributors: ['gpt_architect']
    tags: ['template', 'float', 'error prevention', 'sensor casting']
    confidence_metrics:
      structural: 96
      operational: 95
      semantic: 96
      adoption_recommendation: ready_for_injection
  - id: 'single_domain_sensor_logic_001'
    title: 'Avoid Cross-Domain Logic in One Sensor'
    principle: >
      Sensors must operate within a single semantic domain. Do not mix distinct
      sensor functions or abstractions (e.g., motion and temperature) in one template.
    rationale: >
      Enforces single responsibility, aids maintainability, and ensures sensors
      remain composable and valid across tiers.
    tier: 'γ'
    domain: 'design discipline'
    status: 'approved'
    created: '2025-06-10'
    contributors: ['gpt_architect']
    tags: ['sensor integrity', 'template logic', 'SRP']
    confidence_metrics:
      structural: 95
      operational: 94
      semantic: 95
      adoption_recommendation: ready_for_injection
  - id: 'shared_macro_scoring_001'
    title: 'Use Shared Scoring Formulas Across Sensors'
    principle: >
      Reuse scoring logic via shared macros or standardized blocks rather than duplicating
      scoring templates across rooms or entities.
    rationale: >
      Supports consistency, simplifies debugging, and centralizes behavior updates.
    example:
      good: |
        sensor.motion_score_γ:
          value_template: '{{ macro('motion_score', 'binary_sensor.motion_β') }}'
    tier: 'γ'
    domain: 'macro hygiene'
    status: 'approved'
    created: '2025-06-10'
    contributors: ['gpt_architect']
    tags: ['scoring', 'macros', 'duplication avoidance']
    confidence_metrics:
      structural: 94
      operational: 93
      semantic: 96
      adoption_recommendation: ready_for_injection
  - id: 'binary_output_sanity_check_001'
    title: 'Sanity Check Wrappers Must Yield Binary State'
    principle: >
      All sensors or templates acting as sanity-check wrappers must output 'on' or 'off' only,
      avoiding ambiguous states or custom text.
    rationale: >
      Maintains clarity and ensures compatibility with binary_sensor domains,
      dashboards, and automation logic.
    example:
      good: |
        binary_sensor.kitchen_light_sanity_checked:
          state: >
            {{ states('sensor.kitchen_light_γ') not in ['unknown', 'unavailable'] }}
      avoid: |
        sensor.kitchen_light_sanity_checked:
          state: >
            {{ 'valid' if states('sensor.kitchen_light_γ') not in ['unknown', 'unavailable'] else 'invalid' }}
    tier: 'ε'
    domain: 'diagnostics'
    status: 'approved'
    created: '2025-06-10'
    contributors: ['gpt_architect']
    tags: ['sanity checks', 'binary sensors', 'output validation']
    confidence_metrics:
      structural: 95
      operational: 93
      semantic: 97
      adoption_recommendation: ready_for_injection
  - id: 'weighted_signal_fusion_001'
    title: 'Weighted Signal Fusion for Interpretive Logic'
    principle: >
      Interpretive sensors must use weighted combinations of multiple inputs to determine state,
      rather than relying on single booleans or raw values alone.
    rationale: >
      Reflects environmental complexity, improves decision resilience, and enables fine-grained tuning
      of fusion logic in γ, δ, or ε tiers.
    example:
      good: |
        sensor.presence_score:
          value_template: >-
            {{
              (states('binary_sensor.motion_detected') | int) * 0.6 +
              (states('sensor.beacon_distance') | float < 100) * 0.4
            }}
    tier: 'γ'
    domain: 'fusion logic'
    status: 'approved'
    created: '2025-06-10'
    contributors: ['gpt_architect']
    tags: ['fusion', 'scoring', 'presence logic', 'multi-signal']
    confidence_metrics:
      structural: 95
      operational: 95
      semantic: 96
      adoption_recommendation: ready_for_injection
  - id: 'metadata_injection_beta_layer_001'
    title: 'Metadata Injection in β-Layer Abstractions'
    principle: >
      Validated β-tier entities must embed canonical metadata traditionally associated
      with their α-layer origins, including identifiers, integration context, firmware, and model.
    rationale: >
      Aligns metadata visibility with the abstraction reference layer used in automations and dashboards.
      Decouples behavior from physical device constraints and registry dependencies.
    example:
      good: |
        light.foxy_beta:
          attributes:
            canonical_alpha: light.foxy
            model: 'Candle'
            manufacturer: 'Philips'
            firmware: '1.33.0'
            integration: ['Matter', 'Wiz']
    tier: 'β'
    domain: 'metadata'
    status: 'approved'
    created: '2025-06-10'
    contributors: ['gpt_architect']
    tags: ['abstraction', 'metadata propagation', 'alias integrity']
    confidence_metrics:
      structural: 96
      operational: 94
      semantic: 95
      adoption_recommendation: ready_for_injection
  - id: 'fix_missing_changelog_update_001'
    title: 'Enforce Changelog Update and Version Bump on Sensor Edits'
    principle: >
      Any GPT-applied modification to sensors, templates, or binary sensors must:
      - Append a changelog entry with the date and author tag
      - Increment 'version:' if present
    rationale: >
      Preserves audit trail integrity and prevents silent logic drift across refactored entities.
      Enables validator diffs to align with historical recordkeeping and rollback infrastructure.
    example:
      good: |
        changelog: >
          - 2025-04-10: Created
          - 2025-04-18: Updated suffix and device_class by Sensor Mapper
        version: 1.3
      avoid: |
        changelog: >
          - 2025-04-10: Created
        version: 1.2
    tier: 'μ'
    domain: 'versioning'
    derived_from: 'validator_log.json'
    status: 'parked'
    created: '2025-04-18'
    applied_by: 'nomia'
    contributors: ['gpt_architect']
    tags: ['changelog', 'versioning', 'sensor hygiene']
    confidence_metrics:
      structural: 97
      operational: 93
      semantic: 95
      adoption_recommendation: candidate_for_injection
  - id: 'fix_missing_required_fields_001'
    title: 'Ensure Tier, Canonical ID, and Subsystem Are Present'
    principle: >
      All sensors must include 'tier', 'canonical_id', and 'subsystem' in their metadata block.
      These fields are required for full traceability, validation enforcement, and architectural lineage.
    rationale: >
      Prevents orphaned sensors in audit pipelines and ensures subsystem attribution is structurally visible.
    example:
      good: |
        {
          'sensor_id': 'sensor.humidity_living_room',
          'tier': '_γ',
          'canonical_id': 'sensor.humidity_living_room',
          'subsystem': 'soteria'
        }
      avoid: |
        {
          'sensor_id': 'sensor.humidity_living_room'
        }
    tier: 'μ'
    domain: 'metadata'
    derived_from: 'validator_log.json'
    status: 'parked'
    created: '2025-04-18'
    applied_by: 'nomia'
    contributors: ['gpt_architect']
    tags: ['metadata', 'traceability', 'sensor completeness']
    confidence_metrics:
      structural: 97
      operational: 95
      semantic: 94
      adoption_recommendation: candidate_for_injection
  - id: 'parse_sensor_attributes_metadata_001'
    title: 'Parse Structured Metadata from Sensor Attributes'
    principle: >
      All inline 'sensor_attributes' strings must be parsed into structured fields including
      'changelog', 'version', 'maintainer', and other documented metadata keys.
    rationale: >
      Converts human-readable blobs into machine-validated structures, enabling changelog analysis,
      update tracking, and macro compatibility.
    example:
      good: |
        {
          'changelog': '- 2025-04-10: Created',
          'version': 1.2,
          'maintainer': 'Alex'
        }
      avoid: |
        {
          'sensor_attributes': 'changelog: created on 2025-04-10; version: 1.2; maintainer: Alex'
        }
    tier: 'μ'
    domain: 'metadata parsing'
    derived_from: 'validator_log.json'
    status: 'parked'
    created: '2025-04-18'
    applied_by: 'nomia'
    contributors: ['gpt_architect']
    tags: ['sensor_attributes', 'metadata', 'parsing']
    confidence_metrics:
      structural: 95
      operational: 94
      semantic: 96
      adoption_recommendation: candidate_for_injection
  - id: 'fix_mismatched_device_class_001'
    title: 'Validate device_class Against Declared Sensor Type'
    principle: >
      The 'device_class' must reflect a semantically accurate match for the declared 'sensor_type',
      especially when using a custom tier-based sensor classification.
    rationale: >
      Prevents UI misbehavior, automation errors, and validation pipeline rejection caused by
      misaligned native classes (e.g., showing a humidity sensor as power).
    example:
      good: |
        sensor:
          - platform: template
            sensor_type: 'humidity'
            device_class: 'humidity'
            unique_id: bedroom_humidity_score_γ
            value_template: '{{ states('sensor.humidity_raw_β') | float }}'
      avoid: |
        sensor:
          - platform: template
            sensor_type: 'humidity'
            device_class: 'power'
            unique_id: bedroom_humidity_score_γ
            value_template: '{{ states('sensor.humidity_raw_β') | float }}'
    tier: 'γ'
    domain: 'sensor definition'
    derived_from: 'validator_log.json'
    status: 'parked'
    created: '2025-06-10'
    applied_by: 'nomia'
    contributors: ['gpt_architect']
    tags: ['device_class', 'sensor_type', 'validation']
    confidence_metrics:
      structural: 95
      operational: 92
      semantic: 96
      adoption_recommendation: candidate_for_injection
  - id: 'fix_ambiguous_sensor_location_001'
    title: 'Assign Config Directory Based on Subsystem and Role'
    principle: >
      All sensors must be placed into an appropriate 'config_directory' according to their subsystem,
      tier role, and domain alignment. Ambiguous or placeholder paths (e.g., 'unknown/') are prohibited.
    rationale: >
      Maintains reproducibility and clean abstraction boundaries. Prevents orphaned logic artifacts
      and ensures valid '!include' resolution for 'configuration.yaml' wiring.
    example:
      good: |
        # File: /config/hestia/sensors/alpha/humidity.yaml
        sensor:
          - platform: template
            unique_id: humidity_living_room_α
            value_template: '{{ states('sensor.humidity_living_room_raw') | float }}'
            device_class: humidity
      avoid: |
        # File: /config/unknown/
        sensor:
          - platform: template
            unique_id: humidity_living_room_α
            value_template: '{{ states('sensor.humidity_living_room_raw') | float }}'
    tier: 'α'
    domain: 'placement'
    derived_from: 'validator_log.json'
    status: 'parked'
    created: '2025-06-10'
    applied_by: 'nomia'
    contributors: ['gpt_architect']
    tags: ['sensor placement', 'directory integrity', 'wiring']
    confidence_metrics:
      structural: 96
      operational: 93
      semantic: 94
      adoption_recommendation: candidate_for_injection
  - id: 'tiered_validator_framework_001'
    title: 'Tiered Validator Framework'
    principle: >
      All validator definitions must include a standard metadata block capturing their tier,
      canonical_id, validation source, and review status.
    rationale: >
      Enables auditability, downstream metric correlation, and integration with confidence scoring
      and validation pipelines.
    example:
      good: |
        sensor:
          - platform: template
            name: 'Validator: Presence Integrity'
            tier: 'γ'
            canonical_id: 'presence_validator_gamma'
            validated_by: 'sensor_charon_audit.yaml'
            status: 'active'
      avoid: |
        sensor:
          - platform: template
            name: 'Presence Validator'
    tier: 'γ'
    domain: 'validation'
    status: 'approved'
    created: '2025-04-30'
    applied_by: 'icaria'
    derived_from: 'sensor_charon_audit.yaml, iris_metrics.py'
    used_in: 'confidence_scoring_chain.yaml'
    tags: ['validator', 'metadata', 'confidence']
    confidence_metrics:
      structural: 96
      operational: 95
      semantic: 94
      adoption_recommendation: ready_for_injection
  - id: 'alpha_omega_registry_merge_chain_001'
    title: 'Alpha–Omega Registry Merge Chain'
    principle: >
      Canonical registries in ω-tier must incorporate metadata from α-tier registries using
      canonical_id linkage and structured fallback logic.
    rationale: >
      Preserves signal richness and device context from source registries, while allowing
      canonical consolidation for runtime control and automation traceability.
    example:
      good: |
        # merge_alpha_to_omega_registry.py
        if alpha_entry['canonical_id'] not in omega:
            omega[canonical_id] = enrich_from_alpha(alpha_entry)
      avoid: |
        # overwrite omega blindly
        omega.update(alpha_registry)
    tier: 'ω'
    domain: 'registry'
    status: 'approved'
    created: '2025-04-30'
    applied_by: 'icaria'
    derived_from: 'sync_alpha_to_omega.py'
    used_in: 'automation_alpha_to_omega.yaml'
    tags: ['merge', 'metadata', 'governance']
    confidence_metrics:
      structural: 94
      operational: 96
      semantic: 93
      adoption_recommendation: ready_for_injection
  - id: 'validation_conf_matrix_001'
    title: 'Validation Confidence Matrix'
    principle: >
      Each validator must emit three explicit confidence scores:
      - file_confidence
      - trigger_chain_confidence
      - output_schema_confidence
      These scores guide audit tooling and risk-aware automation execution.
    rationale: >
      Establishes quantifiable trust metrics and aligns validator behavior with HESTIA’s scoring engine.
    example:
      good: |
        sensor:
          - platform: template
            name: 'Validation: Zone Integrity'
            attributes:
              file_confidence: 0.93
              trigger_chain_confidence: 0.88
              output_schema_confidence: 0.91
      avoid: |
        sensor:
          - platform: template
            name: 'Zone Integrity Validator'
    tier: 'γ'
    domain: 'diagnostics'
    status: 'approved'
    created: '2025-04-30'
    applied_by: 'icaria'
    derived_from: 'iris_metrics.py, clio.py'
    used_in: 'sensor.iris_metric_summary'
    tags: ['confidence', 'validator', 'metadata']
    confidence_metrics:
      structural: 97
      operational: 95
      semantic: 96
      adoption_recommendation: ready_for_injection
  - id: 'generated_tool_metadata_sensors'
    title: 'Tool Metadata Sensors Must Reside in core/generated/'
    principle: >
      All sensors that emit file timestamps, diagnostic metadata, or introspective tool state
      (from systems like Clio, Iris, or Panopticon) must be placed in '/config/hestia/core/generated/'
      and assigned to tier 'ε'.
    rationale: >
      Ensures clean separation between system-generated artifacts and human-authored logic.
      Prevents versioning conflicts, supports auto-refresh workflows, and simplifies validation pipelines.
    example:
      good: |
        # File: /config/hestia/core/generated/clio_metadata_sensor.yaml
        sensor:
          - name: 'Clio Metadata'
            state: 'ok'
            attributes:
              tier: 'ε'
              subsystem: 'clio'
      avoid: |
        # File: /config/hestia/packages/hephaestus/clio_config.yaml
        sensor:
          - name: 'Clio Metadata'
            state: 'ok'
            attributes:
              tier: 'γ'
    tier: 'ε'
    domain: 'tooling'
    derived_from: 'validator_log.json'
    status: 'stable'
    created: '2025-04-09'
    applied_by: 'nomia'
    tags: ['telemetry', 'generated', 'introspection']
    confidence_metrics:
      structural: 95
      operational: 94
      semantic: 93
      adoption_recommendation: ready_for_injection
  - id: 'protocol_integration_split_001'
    title: 'Separate Protocol Identity from Integration Implementation'
    principle: >
      Each protocol block in a device descriptor must use the protocol name as the key
      and include an 'integration' field referencing the Home Assistant integration managing it.
    rationale: >
      Decouples the method of communication (protocol) from the integration responsible for implementation,
      enabling abstraction, reuse, and reliable fallback logic.
    example:
      good: |
        'protocol': ['matter', 'wifi']
        'matter':
          canonical_id: 'light.lucetta_mtr'
          integration: 'Matter'
        'wifi':
          canonical_id: 'light.lucetta'
          integration: 'Wiz'
      avoid: |
        'wiz':
          protocol: 'wifi'
          integration: 'Wiz'
    tier: 'β'
    domain: 'protocol-abstraction'
    derived_from: 'conversation_2025-04-09.md'
    status: 'proposed'
    created: '2025-04-09'
    contributors: ['gpt_architect']
    tags: ['integration', 'protocol', 'abstraction']
    confidence_metrics:
      structural: 94
      operational: 95
      semantic: 92
      adoption_recommendation: ready_for_injection
  - id: 'fix_safe_json_parse_with_default'
    title: 'Defensive JSON Parsing for Template Sensors'
    principle: >
      Always guard 'from_json', float conversions, and nested 'state_attr()' calls using
      'default({})' or 'default(0)' before performing template logic on possibly undefined or non-JSON values.
    rationale: >
      Prevents runtime exceptions from 'None', ''unknown'', or missing attributes—especially in diagnostic,
      abstraction, or climate sensors relying on registry metadata or dynamic state payloads.
    example:
      good: |
        {% set raw = state_attr('sensor.config', 'operation_modes') | default('{}') %}
        {% set mode = raw | from_json %}
      avoid: |
        {% set mode = state_attr('sensor.config', 'operation_modes') | from_json %}
    tier: 'β–γ'
    domain: 'template safety'
    derived_from: 'soteria_template_crash_log'
    escalated_from: ['errors in Aether', 'errors in Soteria logic']
    status: 'proposed'
    created: '2025-06-10'
    tags: ['jinja2', 'fault tolerance', 'climate', 'diagnostics']
    confidence_metrics:
      structural: 96
      operational: 92
      semantic: 94
      adoption_recommendation: ready_for_injection
  - id: 'pattern_namespaced_diagnostic_map_001'
    title: 'Use Namespaced Loop for Motion Diagnostic Maps'
    principle: >
      When constructing room-wise diagnostic maps in Jinja templates, use 'namespace()' objects
      and explicit 'dict(...)' accumulation patterns to avoid reassignment errors or unsupported list operations.
    rationale: >
      Standard Jinja2 lacks native list mutation methods. Namespaced dicts enable structured accumulation,
      essential for multi-room motion or presence diagnostics.
    example:
      good: |
        {% set ns = namespace(data={}) %}
        {% for room in rooms %}
          {% set result = is_state('binary_sensor.' ~ room ~ '_motion_γ', 'on') %}
          {% set ns.data = dict(ns.data.items() | list + [(room, result)]) %}
        {% endfor %}
        {{ ns.data | tojson }}
      avoid: |
        {% for room in rooms %}
          {% set data = data.append(room) %}  # Invalid Jinja operation
        {% endfor %}
    tier: 'γ'
    domain: 'diagnostics'
    derived_from: 'motion_diagnostic_template_chain'
    status: 'approved'
    created: '2025-06-10'
    tags: ['jinja', 'mapping', 'sensor map', 'motion']
    confidence_metrics:
      structural: 97
      operational: 94
      semantic: 93
      adoption_recommendation: ready_for_injection
  - id: 'fix_flatten_sensor_key_in_meta_wrapper'
    title: 'Remove Invalid Sensor Root Key from Template Files'
    principle: >
      Files loaded via '!include_dir_merge_list' under 'template:' must not declare a 'sensor:' or 'binary_sensor:' root key.
      Instead, each list item should be directly formatted as a template dictionary.
    rationale: >
      Home Assistant schema validation will fail if top-level keys exist in files merged under 'template:'. Flattening ensures compatibility.
    example:
      good: |
        - name: 'Audit'
          state: 'ok'
      avoid: |
        - sensor:
            - name: 'Audit'
              state: 'ok'
    tier: 'ε'
    domain: 'template file structure'
    derived_from: 'soteria_config.yaml'
    status: 'resolved'
    created: '2025-06-10'
    tags: ['template', 'schema error', 'merge_list']
    confidence_metrics:
      structural: 98
      operational: 97
      semantic: 96
      adoption_recommendation: already_resolved
  - id: 'tier_taxonomy_governance_001'
    title: 'Tier-Based Infrastructure and Logical Flow'
    principle: >
      All configuration, sensor logic, and diagnostic behavior must adhere to HESTIA’s tiered architecture,
      progressing from α (ground truth) to ζ (automation triggers), without skipping intermediate tiers.
    rationale: >
      Enforces modularity, traceability, and composability of sensor logic by clearly assigning roles across
      Alpha (signal emission), Beta (fusion), Gamma (comfort logic), Eta (room/zone aggregation), and Zeta (automations).
    example:
      temperature_domain:
        α: 'Raw sensors (e.g., Zigbee, injected probes)'
        β: 'Sensor smoothing and statistical fusion'
        γ: 'Comfort inference with weights/offsets'
        η: 'Zone-level aggregation of room logic'
        ζ: 'Automation triggers for comfort enforcement'
    tier: 'multi'
    domain: 'abstraction'
    status: 'approved'
    created: '2025-06-10'
    contributors: ['evert', 'promachos']
    tags: ['tiering', 'architecture', 'taxonomy']
    metadata:
      source: hestia_principles.tier_based_infrastructure
      confidence_metrics:
        structural: 98
        operational: 95
        semantic: 96
        adoption_recommendation: ready_for_injection
  - id: 'signal_logic_index_map_001'
    title: 'Signal-Oriented Sensor Logic Must Align with Canonical Indexes'
    principle: >
      All signal logic must reference three structured indexes: signal_emitters.yaml (source registry),
      sensor_class_matrix.yaml (signal classification), and logic_path_index.yaml (signal-to-logic fanout).
    rationale: >
      Enables precise tracing from sensor emitters to automation outcomes, improves macro mapping,
      and enables accurate validator trace synthesis.
    example:
      logic_indexes:
        - signal_emitters.yaml: Raw entity registry and tier anchors
        - sensor_class_matrix.yaml: Logic categorization (motion, climate, etc.)
        - logic_path_index.yaml: Signal → macro → automation fanout map
    tier: 'meta'
    domain: 'validation'
    status: 'approved'
    created: '2025-06-10'
    contributors: ['evert', 'iris']
    tags: ['signal_path', 'indexing', 'macro routing']
    metadata:
      source: hestia_principles.signal_oriented_logic
      confidence_metrics:
        structural: 97
        operational: 96
        semantic: 94
        adoption_recommendation: ready_for_injection
  - id: 'path_contract_discipline_001'
    title: 'Paths and Directory Structures Are Behavioral Contracts'
    principle: >
      All config and logic paths (e.g., sensors/alpha/, inference/, logic/) must reflect architectural intent
      and are enforced as structural contracts, not merely filesystem conveniences.
    rationale: >
      Prevents drift, ensures audit traceability, and supports clean tooling integration for YAML
      scanning, globbing, validator patching, and override shadowing.
    tier: 'ε'
    domain: 'structure'
    status: 'approved'
    created: '2025-06-10'
    contributors: ['evert']
    tags: ['pathing', 'structure', 'contracts']
    metadata:
      source: hestia_principles.file_and_folder_structure
      confidence_metrics:
        structural: 96
        operational: 92
        semantic: 93
        adoption_recommendation: ready_for_injection
  - id: 'macro_template_enforcement_001'
    title: 'Macro-Based Templates Must Be Declarative and Traceable'
    principle: >
      All HESTIA automations and templates must rely on macro libraries to generate logic,
      with enforced macro versioning, usage traceability, and validation readiness.
    rationale: >
      Prevents template duplication, enables dynamic logic injection, supports testing and rollback.
    example:
      valid_macro_sources:
        - template.library.jinja
        - custom_templates/
        - runtime_fanout/
    tier: 'δ'
    domain: 'template logic'
    status: 'approved'
    created: '2025-06-10'
    contributors: ['evert']
    tags: ['template', 'macro', 'validation']
    metadata:
      source: hestia_principles.macro_driven_templates
      confidence_metrics:
        structural: 95
        operational: 94
        semantic: 96
        adoption_recommendation: ready_for_injection
  - id: 'validation_gated_execution_001'
    title: 'Execution Must Be Gated by Confidence and Postcondition Checks'
    principle: >
      All tool-generated logic or config transformations must pass structural, operational, and semantic validation
      before becoming eligible for execution.
    rationale: >
      Prevents deployment of corrupted or incomplete logic, enforces architectural trust and compliance.
    example:
      validation_policy:
        min_file_size: 500 bytes
        manifest_required: true
        confidence_required:
          structural: 70
          operational: 75
          semantic: 80
          average_required: 78
        output_contracts: ['validation_status', 'semantic_continuation', 'affirmation_template']
    tier: 'ε'
    domain: 'validation'
    status: 'approved'
    created: '2025-06-10'
    contributors: ['evert', 'gpt_architect']
    tags: ['validation', 'scoring', 'contracts']
    metadata:
      source: hestia_principles.validation_first_design
      confidence_metrics:
        structural: 97
        operational: 97
        semantic: 97
        adoption_recommendation: ready_for_injection
  - id: 'canonical_index_patch_only_001'
    title: 'All Changes Must Flow Through Patch Contracts and Index Updates'
    principle: >
      The system prohibits direct edits to YAML sensor logic. All changes must flow through patch contracts
      and result in corresponding updates to canonical indexes.
    rationale: >
      Ensures changelog traceability, macro lineage consistency, and validator readiness at every stage of rebuilds.
    example:
      enforcement:
        direct_yaml_editing: false
        patch_contract_required: true
        canonical_index_updates: enforced
    tier: 'meta'
    domain: 'governance'
    status: 'approved'
    created: '2025-06-10'
    contributors: ['evert']
    tags: ['patching', 'indexes', 'rebuild policy']
    metadata:
      source: hestia_principles.declarative_rebuild_philosophy
      confidence_metrics:
        structural: 94
        operational: 96
        semantic: 95
        adoption_recommendation: ready_for_injection
  - id: 'filename_include_consistency_001'
    title: 'Filenames Must Match Purpose for Include Semantics'
    principle: >
      All config files used in '!include_dir_merge_named' blocks must have clear, unambiguous names
      that directly reflect their logic purpose (e.g., motion.yaml, climate_comfort.yaml).
    rationale: >
      Improves traceability, grepability, and prevents filename collision. Required for stable
      directory merging and validator graph tooling.
    example:
      valid_filenames:
        - motion.yaml
        - presence_logic.yaml
      avoid:
        - alpha_motion.yaml
        - 01_base_motion.yaml
    tier: 'ε'
    domain: 'structure'
    status: 'approved'
    created: '2025-06-10'
    contributors: ['evert']
    tags: ['naming', 'directory', 'includes']
    metadata:
      source: filename_normalization_guidance
      confidence_metrics:
        structural: 96
        operational: 94
        semantic: 93
        adoption_recommendation: ready_for_injection
  - id: 'configuration_yaml_include_strategy_001'
    title: 'Reflective Include Strategy for Tiered Sensor Logic'
    principle: >
      The main 'configuration.yaml' file must use '!include_dir_merge_named' for loading tier-aligned logic.
      This enables merge-by-filename behavior and schema compatibility for sensors, templates, and logic chains.
    rationale: >
      Aligns Home Assistant schema with tiered directory layout. Prevents schema errors from multiple root declarations.
    example:
      configuration_yaml_block: |
        sensor: !include_dir_merge_named hestia/sensors/alpha
        template: !include_dir_merge_named hestia/inference
        binary_sensor: !include_dir_merge_named hestia/logic
    tier: 'ε'
    domain: 'configuration structure'
    status: 'approved'
    created: '2025-06-10'
    contributors: ['evert']
    tags: ['configuration.yaml', 'includes', 'schema compliance']
    metadata:
      source: include_strategy_review_2025-06-10
      confidence_metrics:
        structural: 97
        operational: 95
        semantic: 95
        adoption_recommendation: ready_for_injection
  - id: 'prompt_structure_typing_001'
    title: Prompt Subtyping Doctrine
    principle: >
      All prompt files must conform to one of the accepted structural subtypes: trigger, single-intent, or multi-tier suite.
      Each subtype governs expected file length, function, and runtime behavior.
    rationale: >
      Enables consistent prompt validation, reduces token waste, improves LLM grounding, and ensures subtypes are routed to proper validators.
    tier: 'γ'
    domain: abstraction
    status: proposed
    metadata:
      created: '2025-06-11'
      last_updated: '2025-06-11'
      contributors: ['metaarchitect', 'promachos']
      tags: ['prompt', 'registry', 'typing', 'abstraction']
    confidence_metrics:
      structural: 92
      operational: 88
      semantic: 94
      adoption_recommendation: ready_for_injection
    example:
      good: |
        # trigger → under 20 lines, used inline:
        trigger_presence_ping.md
        # single → 1 main logic block:
        single_device_identity_refactor.md
        # suite → protocol-aware scaffold:
        suite_presence_confidence_matrix.md
      avoid: |
        # untyped dump:
        raw_autogen_v1.md
        # prompt that mixes declarative and meta-output:
        messy_fallback_test_case.md
  - id: include_directives_001
    title: Canonical contract for file-loading strategies in Home Assistant configs
    directives:
    - id: include_dir_list
      description: Loads YAML files as single list entries in lex order.
      required_shape: single item per file
      merged_output: list
      path_type: directory
      canonical_usage: |
        automation: !include_dir_list automations/
    - id: include_dir_named
      description: Loads YAML files and maps them by filename.
      required_shape: mapping per file
      merged_output: dict
      path_type: directory
      canonical_usage: |
        sensors: !include_dir_named sensor_definitions/
    - id: include_dir_merge_list
      description: Merges list items across YAML files into one list.
      required_shape: lists (multi-item OK)
      merged_output: flattened list
      path_type: directory
      canonical_usage: |
        automation: !include_dir_merge_list automations/manual/
    - id: include_dir_merge_named
      description: Merges mappings across YAML files by key.
      required_shape: dicts with overlapping keys allowed
      merged_output: unified dict (last wins)
      path_type: directory
      canonical_usage: |
        template: !include_dir_merge_named templates/
    rules: >
      - 'no file may use !include_dir_merge_list with non-list YAML'
      - '!include_dir_named files must not have duplicate top-level keys'
      - 'directory paths must be relative to '/config/' and contain '.yaml' only'
  - id: package_folder_structure_002
    title: Package folder directive
    principle: >
      Using 'packages:' with '!include_dir_named' is the canonical method for modular YAML packages in HA.
    rationale: >
      Packages allow grouping related configurations (sensors, automations, scripts) under a single folder
      while preserving namespacing and load order. This simplifies configuration packaging.
    tier: 'β+'
    domain: abstraction
    status: proposed
    metadata:
      created: '2025-06-12'
      last_updated: '2025-06-12'
      contributors: ['metaarchitect', 'promachos', 'hestia']
      derived_from: 'https://www.home-assistant.io/docs/configuration/packages/#create-a-packages-folder'
      tags: ['packages', 'include', 'abstraction']
    confidence_metrics:
      structural: 93
      operational: 90
      semantic: 92
      adoption_recommendation: ready_for_injection
    example:
      good: |
        homeassistant:
          packages: !include_dir_named integrations/
      avoid: |
        homeassistant:
          packages: ../integrations/  # non-relative or non-directory path
    guideline: >
      Package folders must live under '/config/', each subfolder maps to one package name. Only '.yaml' files accepted.
  - id: loader_code_enforced_rule_003
    title: YAML loader file-extension enforcement
    principle: >
      Loader at core always filters for '.yaml' extension and ignores '.yml'.
    rationale: >
      To maintain consistency and loading behavior, only files ending with '.yaml' are processed.
    tier: 'β'
    domain: abstraction
    status: approved
    metadata:
      created: '2025-06-12'
      last_updated: '2025-06-12'
      contributors: ['metaarchitect', 'hestia']
      derived_from: 'homeassistant/util/yaml/loader.py:276'
      tags: ['loader', 'extensions']
    confidence_metrics:
      structural: 97
      operational: 95
      semantic: 96
      adoption_recommendation: ready_for_injection
    example:
      good: |
        sensors/
          temp_sensor.yaml
      avoid: |
        sensors/temp_sensor.yml
    guideline: >
      Scan loader code ensures '.yaml' only -- do not create '.yml' files in include folders.
  - id: package_folder_structure_002
    title: Package folder directive
    principle: >
      Using 'packages:' with '!include_dir_named' is the canonical method for modular YAML packages in HA.
    rationale: >
      Packages allow grouping related configurations (sensors, automations, scripts) under a single folder
      while preserving namespacing and load order. This simplifies configuration packaging.
    tier: 'β+'
    domain: abstraction
    status: proposed
    metadata:
      created: '2025-06-12'
      last_updated: '2025-06-12'
      contributors: ['metaarchitect', 'promachos', 'hestia']
      derived_from: 'https://www.home-assistant.io/docs/configuration/packages/#create-a-packages-folder'
      tags: ['packages', 'include', 'abstraction']
    confidence_metrics:
      structural: 93
      operational: 90
      semantic: 92
      adoption_recommendation: ready_for_injection
    example:
      good: |
        homeassistant:
          packages: !include_dir_named integrations/
      avoid: |
        homeassistant:
          packages: ../integrations/  # non-relative or non-directory path
    guideline: >
      Package folders must live under '/config/', each subfolder maps to one package name. Only '.yaml' files accepted.
  - id: loader_code_enforced_rule_003
    title: YAML loader file-extension enforcement
    principle: >
      Loader at core always filters for '.yaml' extension and ignores '.yml'.
    rationale: >
      To maintain consistency and loading behavior, only files ending with '.yaml' are processed.
    tier: 'β'
    domain: abstraction
    status: approved
    metadata:
      created: '2025-06-12'
      last_updated: '2025-06-12'
      contributors: ['metaarchitect', 'hestia']
      derived_from: 'homeassistant/util/yaml/loader.py:276'
      tags: ['loader', 'extensions']
    confidence_metrics:
      structural: 97
      operational: 95
      semantic: 96
      adoption_recommendation: ready_for_injection
    example:
      good: |
        sensors/
          temp_sensor.yaml
      avoid: |
        sensors/temp_sensor.yml
    guideline: >
      Scan loader code ensures '.yaml' only -- do not create '.yml' files in include folders.
  - id: 'package_shape_compatibility_004'
    title: Loader shape requirement for 'packages:' + include_dir_named
    principle: >
      All packages loaded via 'packages: !include_dir_named' must resolve to top-level dictionaries.
    rationale: >
      YAML loader expects each file under a named include to define a dict-structured config (e.g., 'sensor:' block).
    tier: 'α'
    domain: configuration
    status: enforced
    metadata:
      created: '2025-06-12'
      derived_from: 'https://www.home-assistant.io/docs/configuration/packages/'
    confidence_metrics:
      structural: 96
      operational: 94
      semantic: 97
    example:
      good: |
        light:
          - platform: demo
      avoid: |
        - platform: demo
